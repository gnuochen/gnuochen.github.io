<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TreadLocal</title>
      <link href="/wiki/java/TreadLocal/"/>
      <url>/wiki/java/TreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/wiki/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/wiki/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设计模式的六大原则"><a href="#1-设计模式的六大原则" class="headerlink" title="1.设计模式的六大原则"></a>1.设计模式的六大原则</h2><ul><li><h3 id="开闭原则（Open-close-principle）"><a href="#开闭原则（Open-close-principle）" class="headerlink" title="开闭原则（Open close principle）"></a>开闭原则（Open close principle）</h3><p>软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p></li><li><h3 id="里氏替换原则（Liskov-substitution-principle）"><a href="#里氏替换原则（Liskov-substitution-principle）" class="headerlink" title="里氏替换原则（Liskov substitution principle）"></a>里氏替换原则（Liskov substitution principle）</h3><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 </p><p>1、里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</p><p>2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</p></li><li><h3 id="依赖倒转原则-（Dependence-iversion-principle）"><a href="#依赖倒转原则-（Dependence-iversion-principle）" class="headerlink" title="依赖倒转原则 （Dependence iversion principle）"></a>依赖倒转原则 （Dependence iversion principle）</h3><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p></li><li><h3 id="接口隔离原则（interface-segregation-principle）"><a href="#接口隔离原则（interface-segregation-principle）" class="headerlink" title="接口隔离原则（interface segregation principle）"></a>接口隔离原则（interface segregation principle）</h3><p>使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p></li><li><h3 id="迪米特原则-最少知道原则（Demeter-principle）"><a href="#迪米特原则-最少知道原则（Demeter-principle）" class="headerlink" title="迪米特原则-最少知道原则（Demeter principle）"></a>迪米特原则-最少知道原则（Demeter principle）</h3><p>　也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与”陌生人”说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p></li><li><h3 id="合成复用原则（composite-reuse-principle）"><a href="#合成复用原则（composite-reuse-principle）" class="headerlink" title="合成复用原则（composite reuse principle）"></a>合成复用原则（composite reuse principle）</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。、</p></li><li><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p> 对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。</p><p>​</p></li></ul><h2 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2.设计模式分类"></a>2.设计模式分类</h2><h3 id="2-1-总体来说设计模式分为三大类："><a href="#2-1-总体来说设计模式分为三大类：" class="headerlink" title="2.1 总体来说设计模式分为三大类："></a>2.1 总体来说设计模式分为三大类：</h3><p>​     （1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>​     （2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>​     （3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h3 id="2-2-一张图说明23种设计模式直接的关系"><a href="#2-2-一张图说明23种设计模式直接的关系" class="headerlink" title="2.2 一张图说明23种设计模式直接的关系"></a>2.2 一张图说明23种设计模式直接的关系</h3><img src="/wiki/design/设计模式总结/23种设计模式之间的关系.jpg" title="[23种设计模式之间的关系]"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/az4215/p/11489712.html" rel="external nofollow noopener noreferrer" target="_blank">设计模式六大原则</a></li><li><a href="https://blog.csdn.net/wanbf123/article/details/72528705" rel="external nofollow noopener noreferrer" target="_blank">设计模式结构图及设计原则</a></li><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/" rel="external nofollow noopener noreferrer" target="_blank">Graphic Design patterns</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>default</title>
      <link href="/wiki/python/default/"/>
      <url>/wiki/python/default/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用idea插件汇总</title>
      <link href="/wiki/tools/%E5%B8%B8%E7%94%A8idea%20%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
      <url>/wiki/tools/%E5%B8%B8%E7%94%A8idea%20%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/wiki/algorithm/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/wiki/algorithm/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-算法的分类"><a href="#1-算法的分类" class="headerlink" title="1.算法的分类"></a>1.算法的分类</h2><img src="/wiki/algorithm/十大经典排序算法/排序算法分类.png" title="[排序算法分类]"><h2 id="2-各算法性能比较"><a href="#2-各算法性能比较" class="headerlink" title="2.各算法性能比较"></a>2.各算法性能比较</h2><table><thead><tr><th>排序方法</th><th>时间复杂度（平均）</th><th>时间复杂度（最差）</th><th>时间复杂度（最好）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog~2n)</td><td>O(n^2)</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(n)</td><td>稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计数排序</td><td>O(n+K)</td><td>O(n+K)</td><td>O(n+K)</td><td>O(n+K)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+K)</td><td>O(n^2)</td><td>O(n)</td><td>O(n+K)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>稳定</td></tr></tbody></table><p><em>相关概念</em></p><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p><p><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p></blockquote><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><h3 id="3-1-冒泡排序（Bubble-sort）"><a href="#3-1-冒泡排序（Bubble-sort）" class="headerlink" title="3.1 冒泡排序（Bubble sort）"></a>3.1 冒泡排序（Bubble sort）</h3><p>​    冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="3-1-1算法描述"><a href="#3-1-1算法描述" class="headerlink" title="3.1.1算法描述"></a>3.1.1算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h4 id="3-1-2-动图演示"><a href="#3-1-2-动图演示" class="headerlink" title="3.1.2 动图演示"></a>3.1.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/bubble_sort.gif" title="[冒泡排序]"><h4 id="3-1-3-代码实现"><a href="#3-1-3-代码实现" class="headerlink" title="3.1.3 代码实现"></a>3.1.3 代码实现</h4><pre><code class="java">    public static int[] bubbleSort(int[] array) {        if (array.length == 0)            return array;        for (int i = 0; i &lt; array.length; i++)            for (int j = 0; j &lt; array.length - 1 - i; j++)                if (array[j + 1] &lt; array[j]) {                    int temp = array[j + 1];                    array[j + 1] = array[j];                    array[j] = temp;                }        return array;    }</code></pre><h3 id="3-2-快速排序-quick-sort"><a href="#3-2-快速排序-quick-sort" class="headerlink" title="3.2 快速排序(quick sort)"></a>3.2 快速排序(quick sort)</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="3-2-1-算法描述"><a href="#3-2-1-算法描述" class="headerlink" title="3.2.1 算法描述"></a>3.2.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="3-2-2-动图演示"><a href="#3-2-2-动图演示" class="headerlink" title="3.2.2 动图演示"></a>3.2.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/quick_sort.gif" title="[快速排序]"><h4 id="3-2-3-代码实现"><a href="#3-2-3-代码实现" class="headerlink" title="3.2.3 代码实现"></a>3.2.3 代码实现</h4><pre><code class="java">//快速排序方法public static int[] QuickSort(int[] array, int start, int end) {    if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;    int smallIndex = partition(array, start, end);    if (smallIndex &gt; start)        QuickSort(array, start, smallIndex - 1);    if (smallIndex &lt; end)        QuickSort(array, smallIndex + 1, end);    return array;}// 快速排序算法——partitionpublic static int partition(int[] array, int start, int end) {    int pivot = (int) (start + Math.random() * (end - start + 1));    int smallIndex = start - 1;    swap(array, pivot, end);    for (int i = start; i &lt;= end; i++)        if (array[i] &lt;= array[end]) {            smallIndex++;            if (i &gt; smallIndex)                swap(array, i, smallIndex);        }    return smallIndex;}// 交换数组内两个元素public static void swap(int[] array, int i, int j) {    int temp = array[i];    array[i] = array[j];    array[j] = temp;}</code></pre><h3 id="3-3-插入排序（insertion-sort）"><a href="#3-3-插入排序（insertion-sort）" class="headerlink" title="3.3 插入排序（insertion sort）"></a>3.3 插入排序（insertion sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="3-3-1-算法描述"><a href="#3-3-1-算法描述" class="headerlink" title="3.3.1 算法描述"></a>3.3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-3-2-动图演示"><a href="#3-3-2-动图演示" class="headerlink" title="3.3.2 动图演示"></a>3.3.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/insertion_sort.gif" title="[插入排序]"><h4 id="3-3-3-代码实现"><a href="#3-3-3-代码实现" class="headerlink" title="3.3.3 代码实现"></a>3.3.3 代码实现</h4><pre><code class="java">public static int[] insertionSort(int[] array) {    if (array.length == 0)        return array;    int current;    for (int i = 0; i &lt; array.length - 1; i++) {        current = array[i + 1];        int preIndex = i;        while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) {            array[preIndex + 1] = array[preIndex];            preIndex--;        }        array[preIndex + 1] = current;    }    return array;}</code></pre><h3 id="3-4-希尔排序（shell-sort）"><a href="#3-4-希尔排序（shell-sort）" class="headerlink" title="3.4 希尔排序（shell sort）"></a>3.4 希尔排序（shell sort）</h3><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p><h4 id="3-4-1-算法描述"><a href="#3-4-1-算法描述" class="headerlink" title="3.4.1 算法描述"></a>3.4.1 算法描述</h4><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="3-4-2-动图演示"><a href="#3-4-2-动图演示" class="headerlink" title="3.4.2 动图演示"></a>3.4.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/shell_sort.gif" title="[缩小增量排序]"><h4 id="3-4-3-代码实现"><a href="#3-4-3-代码实现" class="headerlink" title="3.4.3 代码实现"></a>3.4.3 代码实现</h4><pre><code class="java">public static int[] ShellSort(int[] array) {    int len = array.length;    int temp, gap = len / 2;    while (gap &gt; 0) {        for (int i = gap; i &lt; len; i++) {            temp = array[i];            int preIndex = i - gap;            while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {                array[preIndex + gap] = array[preIndex];                preIndex -= gap;            }            array[preIndex + gap] = temp;        }        gap /= 2;    }    return array;}</code></pre><h3 id="3-5-选择排序（selection-sort）"><a href="#3-5-选择排序（selection-sort）" class="headerlink" title="3.5 选择排序（selection sort）"></a>3.5 选择排序（selection sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="3-5-1-算法描述"><a href="#3-5-1-算法描述" class="headerlink" title="3.5.1 算法描述"></a>3.5.1 算法描述</h4><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="3-5-2-动图演示"><a href="#3-5-2-动图演示" class="headerlink" title="3.5.2 动图演示"></a>3.5.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/selection_sort.gif" title="[选择排序]"><h4 id="3-5-3-代码实现"><a href="#3-5-3-代码实现" class="headerlink" title="3.5.3 代码实现"></a>3.5.3 代码实现</h4><pre><code class="java">public static int[] selectionSort(int[] array) {    if (array.length == 0)        return array;    for (int i = 0; i &lt; array.length; i++) {        int minIndex = i;        for (int j = i; j &lt; array.length; j++) {            if (array[j] &lt; array[minIndex]) //找到最小的数                minIndex = j; //将最小数的索引保存        }        int temp = array[minIndex];        array[minIndex] = array[i];        array[i] = temp;    }    return array;}</code></pre><h3 id="3-6-堆排序（Heap-sort）"><a href="#3-6-堆排序（Heap-sort）" class="headerlink" title="3.6 堆排序（Heap sort）"></a>3.6 堆排序（Heap sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="3-6-1-算法描述"><a href="#3-6-1-算法描述" class="headerlink" title="3.6.1 算法描述"></a>3.6.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="3-6-2-动图演示"><a href="#3-6-2-动图演示" class="headerlink" title="3.6.2 动图演示"></a>3.6.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/heap_sort.gif" title="[堆排序]"><h4 id="3-6-3-代码实现"><a href="#3-6-3-代码实现" class="headerlink" title="3.6.3 代码实现"></a>3.6.3 代码实现</h4><pre><code class="java">//声明全局变量，用于记录数组array的长度；static int len;// 堆排序算法public static int[] heapSort(int[] array) {    len = array.length;    if (len &lt; 1) return array;    //1.构建一个最大堆    buildMaxHeap(array);    System.out.println(&quot;第一次构建最大堆：&quot;+ Arrays.toString(array));    //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆    while (len &gt; 0) {        swap(array, 0, len - 1);        len--;        adjustHeap(array, 0);        System.out.println(&quot;len:&quot;+len+&quot;构建后为：&quot;+Arrays.toString(array));    }    return array;}//建立最大堆public static void buildMaxHeap(int[] array) {    //从最后一个非叶子节点开始向上构造最大堆    for (int i = (len/2 - 1); i &gt;= 0; i--) { //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1)        adjustHeap(array, i);    }}//调整使之成为最大堆 public static void adjustHeap(int[] array, int i) {    int maxIndex = i;    //如果有左子树，且左子树大于父节点，则将最大指针指向左子树    if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])        maxIndex = i * 2;    //如果有右子树，且右子树大于父节点，则将最大指针指向右子树    if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])        maxIndex = i * 2 + 1;    //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。    if (maxIndex != i) {        swap(array, maxIndex, i);        adjustHeap(array, maxIndex);    }}</code></pre><h3 id="3-7-归并排序（Merge-sort）"><a href="#3-7-归并排序（Merge-sort）" class="headerlink" title="3.7 归并排序（Merge sort）"></a>3.7 归并排序（Merge sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h4 id="3-7-1-算法描述"><a href="#3-7-1-算法描述" class="headerlink" title="3.7.1 算法描述"></a>3.7.1 算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="3-7-2-动图演示"><a href="#3-7-2-动图演示" class="headerlink" title="3.7.2 动图演示"></a>3.7.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/merge_sort.gif" title="[归并排序]"><h4 id="3-7-3-代码实现"><a href="#3-7-3-代码实现" class="headerlink" title="3.7.3 代码实现"></a>3.7.3 代码实现</h4><pre><code class="java">// 归并排序public static int[] MergeSort(int[] array) {    if (array.length &lt; 2) return array;    int mid = array.length / 2;    int[] left = Arrays.copyOfRange(array, 0, mid);    int[] right = Arrays.copyOfRange(array, mid, array.length);    return merge(MergeSort(left), MergeSort(right));}//归并排序——将两段排序好的数组结合成一个排序数组public static int[] merge(int[] left, int[] right) {    int[] result = new int[left.length + right.length];    for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {        if (i &gt;= left.length)            result[index] = right[j++];        else if (j &gt;= right.length)            result[index] = left[i++];        else if (left[i] &gt; right[j])            result[index] = right[j++];        else            result[index] = left[i++];    }    return result;}</code></pre><h3 id="3-8-计数排序（counting-sort）"><a href="#3-8-计数排序（counting-sort）" class="headerlink" title="3.8 计数排序（counting sort）"></a>3.8 计数排序（counting sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="3-8-1-算法描述"><a href="#3-8-1-算法描述" class="headerlink" title="3.8.1 算法描述"></a>3.8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="3-8-2-动图演示"><a href="#3-8-2-动图演示" class="headerlink" title="3.8.2 动图演示"></a>3.8.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/counting_sort.gif" title="[计数排序]"><h4 id="3-8-3-代码实现"><a href="#3-8-3-代码实现" class="headerlink" title="3.8.3 代码实现"></a>3.8.3 代码实现</h4><pre><code class="java">// 计数排序public static int[] CountingSort(int[] array) {    if (array.length == 0) return array;    int bias, min = array[0], max = array[0];    for (int i = 1; i &lt; array.length; i++) {        if (array[i] &gt; max)            max = array[i];        if (array[i] &lt; min)            min = array[i];    }    bias = 0 - min;    int[] bucket = new int[max - min + 1];    Arrays.fill(bucket, 0);    for (int i = 0; i &lt; array.length; i++) {        bucket[array[i] + bias]++;    }    int index = 0, i = 0;    while (index &lt; array.length) {        if (bucket[i] != 0) {            array[index] = i - bias;            bucket[i]--;            index++;        } else            i++;    }    return array;}</code></pre><h3 id="3-9-桶排序（Bucket-sort）"><a href="#3-9-桶排序（Bucket-sort）" class="headerlink" title="3.9 桶排序（Bucket sort）"></a>3.9 桶排序（Bucket sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="3-9-1-算法描述"><a href="#3-9-1-算法描述" class="headerlink" title="3.9.1 算法描述"></a>3.9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="3-9-2-动图演示"><a href="#3-9-2-动图演示" class="headerlink" title="3.9.2 动图演示"></a>3.9.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/bucket_sort.gif" title="[桶排序]"><h4 id="3-9-3-代码实现"><a href="#3-9-3-代码实现" class="headerlink" title="3.9.3 代码实现"></a>3.9.3 代码实现</h4><pre><code class="java">// 桶排序public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) {    if (array == null || array.size() &lt; 2)        return array;    int max = array.get(0), min = array.get(0);    // 找到最大值最小值    for (int i = 0; i &lt; array.size(); i++) {        if (array.get(i) &gt; max)            max = array.get(i);        if (array.get(i) &lt; min)            min = array.get(i);    }    int bucketCount = (max - min) / bucketSize + 1;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);    ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; bucketCount; i++) {        bucketArr.add(new ArrayList&lt;Integer&gt;());    }    for (int i = 0; i &lt; array.size(); i++) {        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));    }    for (int i = 0; i &lt; bucketCount; i++) {        if (bucketSize == 1) { // 如果带排序数组中有重复数字时            for (int j = 0; j &lt; bucketArr.get(i).size(); j++)                resultArr.add(bucketArr.get(i).get(j));        } else {            if (bucketCount == 1)                bucketSize--;            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);            for (int j = 0; j &lt; temp.size(); j++)                resultArr.add(temp.get(j));        }    }    return resultArr;}</code></pre><h3 id="3-10-基数排序-（Radix-sort）"><a href="#3-10-基数排序-（Radix-sort）" class="headerlink" title="3.10 基数排序 （Radix sort）"></a>3.10 基数排序 （Radix sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="3-10-1-算法描述"><a href="#3-10-1-算法描述" class="headerlink" title="3.10.1 算法描述"></a>3.10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="3-10-2-动图演示"><a href="#3-10-2-动图演示" class="headerlink" title="3.10.2 动图演示"></a>3.10.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/radix_sort.gif" title="[基数排序]"><h4 id="3-10-3-代码实现"><a href="#3-10-3-代码实现" class="headerlink" title="3.10.3 代码实现"></a>3.10.3 代码实现</h4><pre><code class="java">//基数排序public static int[] RadixSort(int[] array) {    if (array == null || array.length &lt; 2)        return array;    // 1.先算出最大数的位数；    int max = array[0];    for (int i = 1; i &lt; array.length; i++) {        max = Math.max(max, array[i]);    }    int maxDigit = 0;    while (max != 0) {        max /= 10;        maxDigit++;    }    int mod = 10, div = 1;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();    for (int i = 0; i &lt; 10; i++)        bucketList.add(new ArrayList&lt;Integer&gt;());    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) {        for (int j = 0; j &lt; array.length; j++) {            int num = (array[j] % mod) / div;            bucketList.get(num).add(array[j]);        }        int index = 0;        for (int j = 0; j &lt; bucketList.size(); j++) {            for (int k = 0; k &lt; bucketList.get(j).size(); k++)                array[index++] = bucketList.get(j).get(k);            bucketList.get(j).clear();        }    }    return array;}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/zhi-ming/p/10453124.html" rel="external nofollow noopener noreferrer" target="_blank">十大经典排序算法（动图演示）</a></li><li><a href="https://blog.csdn.net/wq_1995/article/details/81937926#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89" rel="external nofollow noopener noreferrer" target="_blank">十大经典排序算法总结（Java语言实现）</a></li><li><a href="https://www.sohu.com/a/278768401_478315" rel="external nofollow noopener noreferrer" target="_blank">【图解数据结构】 一组动画彻底理解桶排序 </a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>default</title>
      <link href="/wiki/database/h2/default/"/>
      <url>/wiki/database/h2/default/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> h2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>default</title>
      <link href="/wiki/database/sql/default/"/>
      <url>/wiki/database/sql/default/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合框架</title>
      <link href="/wiki/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/wiki/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="java8集合架构"><a href="#java8集合架构" class="headerlink" title="java8集合架构"></a>java8集合架构</h2><h3 id="常用成员"><a href="#常用成员" class="headerlink" title="常用成员"></a>常用成员</h3><img src="/wiki/java/java集合框架/集合框架架构.png" title="[集合常用成员]"><h3 id="Collection-接口系单列集合"><a href="#Collection-接口系单列集合" class="headerlink" title="Collection 接口系单列集合"></a>Collection 接口系单列集合</h3><img src="/wiki/java/java集合框架/Iterable.png" title="[collection]"><h3 id="Map-接口系双列集合"><a href="#Map-接口系双列集合" class="headerlink" title="Map 接口系双列集合"></a>Map 接口系双列集合</h3><img src="/wiki/java/java集合框架/Map.png" title="[Map]"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud架构</title>
      <link href="/wiki/spring/springcloud/SpringCloud%E6%9E%B6%E6%9E%84/"/>
      <url>/wiki/spring/springcloud/SpringCloud%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><img src="/wiki/spring/springcloud/SpringCloud架构/Springcloud微服务架构图1.png" title="[]"><img src="/wiki/spring/springcloud/SpringCloud架构/Springcloud微服务架构图2.png" title="[]"><hr><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li><h3 id="netflix-Eureka："><a href="#netflix-Eureka：" class="headerlink" title="netflix-Eureka："></a>netflix-Eureka：</h3><p>各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</p></li><li><h3 id="netflix-Ribbon："><a href="#netflix-Ribbon：" class="headerlink" title="netflix-Ribbon："></a>netflix-Ribbon：</h3><p>服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p></li><li><h3 id="netflix-Feign："><a href="#netflix-Feign：" class="headerlink" title="netflix-Feign："></a>netflix-Feign：</h3><p>基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p></li><li><h3 id="netflix-Hystrix："><a href="#netflix-Hystrix：" class="headerlink" title="netflix-Hystrix："></a>netflix-Hystrix：</h3><p>发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p></li><li><h3 id="netflix-Zuul："><a href="#netflix-Zuul：" class="headerlink" title="netflix-Zuul："></a>netflix-Zuul：</h3><p>如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</p></li><li><h3 id="netflix-Archaius"><a href="#netflix-Archaius" class="headerlink" title="netflix-Archaius:"></a>netflix-Archaius:</h3><p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</p><hr><p>​</p></li><li><h3 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h3><p>配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。</p></li><li><h3 id="Cloud-Bus："><a href="#Cloud-Bus：" class="headerlink" title="Cloud Bus："></a>Cloud Bus：</h3><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p></li><li><h3 id="Spring-Cloud-Sleuth："><a href="#Spring-Cloud-Sleuth：" class="headerlink" title="Spring Cloud Sleuth："></a>Spring Cloud Sleuth：</h3><p>日志收集工具包，封装了Dapper,Zipkin和HTrace操作。</p></li><li><h3 id="Spring-Cloud-Data-Flow："><a href="#Spring-Cloud-Data-Flow：" class="headerlink" title="Spring Cloud Data Flow："></a>Spring Cloud Data Flow：</h3><p>大数据操作工具，通过命令行方式操作数据流。</p></li><li><h3 id="Spring-Cloud-Security："><a href="#Spring-Cloud-Security：" class="headerlink" title="Spring Cloud Security："></a>Spring Cloud Security：</h3><p>安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。</p></li><li><h3 id="Spring-Cloud-Consul："><a href="#Spring-Cloud-Consul：" class="headerlink" title="Spring Cloud Consul："></a>Spring Cloud Consul：</h3><p>封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p></li><li><h3 id="Spring-Cloud-Zookeeper："><a href="#Spring-Cloud-Zookeeper：" class="headerlink" title="Spring Cloud Zookeeper："></a>Spring Cloud Zookeeper：</h3><p>操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。</p></li><li><h3 id="Spring-Cloud-Stream："><a href="#Spring-Cloud-Stream：" class="headerlink" title="Spring Cloud Stream："></a>Spring Cloud Stream：</h3><p>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</p></li><li><h3 id="Spring-Cloud-CLI："><a href="#Spring-Cloud-CLI：" class="headerlink" title="Spring Cloud CLI："></a>Spring Cloud CLI：</h3><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p></li><li><h3 id="Spring-Cloud-for-Cloud-Foundry："><a href="#Spring-Cloud-for-Cloud-Foundry：" class="headerlink" title="Spring Cloud for Cloud Foundry："></a>Spring Cloud for Cloud Foundry：</h3><p>通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><p><a href="https://blog.csdn.net/wujian_csdn_csdn/article/details/81701320" rel="external nofollow noopener noreferrer" target="_blank">SpringCloud微服务架构</a></p><p>​</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot 启动流程分析</title>
      <link href="/wiki/spring/springboot/springboot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/wiki/spring/springboot/springboot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-启动入口-（SrpingApplication）"><a href="#1-启动入口-（SrpingApplication）" class="headerlink" title="1.启动入口 （SrpingApplication）"></a>1.启动入口 （SrpingApplication）</h2><p> 大家熟悉的springboot的启动类，@SpringBootApplicationv + psvm（main方法）+ new SpringApplication().run(XXXX.class, args)</p><pre><code class="java">@SpringBootApplicationpublic class SummaryApplication {    public static void main(String[] args) {        SpringApplication application = new SpringApplication(); // 2        application.run(SummaryApplication.class, args); //3//      SpringApplication.run(SummaryApplication.class, args);  也可简化调用静态方法    }}</code></pre><h3 id="1-1-SpringBootApplication-注解"><a href="#1-1-SpringBootApplication-注解" class="headerlink" title="1.1 @SpringBootApplication 注解"></a>1.1 @SpringBootApplication 注解</h3><p>通过源码发现该注解只是@Configuration，@EnableAutoConfiguration，@ComponentScan 三个注解的组合，这是在springboot 1.5以后为这三个注解做的一个简写。接下来简单说下这三个注解的功能：</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration //1.1.1 注册为配置类@EnableAutoConfiguration //1.1.2 配置可自动装配@ComponentScan(excludeFilters = { //1.1.3 声明可扫描Bean   @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),  @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {  ...}</code></pre><h4 id="1-1-1-SpringBootConfiguration"><a href="#1-1-1-SpringBootConfiguration" class="headerlink" title="1.1.1 @SpringBootConfiguration"></a>1.1.1 @SpringBootConfiguration</h4><p>该注解就是spirng ioc容器中java config 配置方式的@Configuration ，注册当前类为spring ioc容器的配置类。</p><p>搭配@bean注解创建一个简单spring ioc配置类</p><pre><code class="java"> @Configuration      public class Conf {          @Bean          public Car car() {             Car car = new Car();              car.setWheel(wheel());              return car;          }         @Bean          public Wheel wheel() {              return new Wheel();          }      }</code></pre><h4 id="1-1-2-EnableAutoConfiguration"><a href="#1-1-2-EnableAutoConfiguration" class="headerlink" title="1.1.2 @EnableAutoConfiguration"></a>1.1.2 @EnableAutoConfiguration</h4><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class) //最为重要public @interface EnableAutoConfiguration {   String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;   /**    * Exclude specific auto-configuration classes such that they will never be applied.    * @return the classes to exclude    */   Class&lt;?&gt;[] exclude() default {};   /**    * Exclude specific auto-configuration class names such that they will never be    * applied.    * @return the class names to exclude    * @since 1.3.0    */   String[] excludeName() default {};}</code></pre><p>@EnableAutoConfiguration借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p><p><strong>最关键的要属@Import(EnableAutoConfigurationImportSelector.class)</strong> ，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p><h4 id="1-1-3-ComponentScan"><a href="#1-1-3-ComponentScan" class="headerlink" title="1.1.3 @ComponentScan"></a>1.1.3 @ComponentScan</h4><p>@ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p><h2 id="2-构造器（Constructor）"><a href="#2-构造器（Constructor）" class="headerlink" title="2.构造器（Constructor）"></a>2.构造器（Constructor）</h2><pre><code class="java">/** * Create a new {@link SpringApplication} instance. The application context will load * beans from the specified primary sources (see {@link SpringApplication class-level} * documentation for details. The instance can be customized before calling * {@link #run(String...)}. * @param resourceLoader the resource loader to use * @param primarySources the primary bean sources * @see #run(Class, String[]) * @see #setSources(Set) */@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {   this.resourceLoader = resourceLoader;   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);   this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));   //2.1 判断当前程序类型   this.webApplicationType = WebApplicationType.deduceFromClasspath();   //2.2 使用SpringFactoriesLoader 实例化所有可用的初始器   setInitializers((Collection)                            getSpringFactoriesInstances(ApplicationContextInitializer.class));   //2.3 使用SpringFactoriesLoader 实例化所有可用的监听器  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));   //2.4 配置应用主方法所在类   this.mainApplicationClass = deduceMainApplicationClass();}</code></pre><h4 id="2-1-判断当前程序类型"><a href="#2-1-判断当前程序类型" class="headerlink" title="2.1 判断当前程序类型"></a>2.1 判断当前程序类型</h4><p>根据classpath里面是否存在某个特征类</p><p>（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</p><pre><code>/** * The application should not run as a web application and should not start an * embedded web server. */NONE,/** * The application should run as a servlet-based web application and should start an * embedded servlet web server. */SERVLET,/** * The application should run as a reactive web application and should start an * embedded reactive web server. */REACTIVE;</code></pre><h2 id="3-启动方法（RUN）"><a href="#3-启动方法（RUN）" class="headerlink" title="3.启动方法（RUN）"></a>3.启动方法（RUN）</h2><p>初始化完成之后就进到了run方法，run方法完成了所有Spring的整个启动过程：</p><ul><li><p>准备Environment</p></li><li><p>发布事件</p></li><li><p>创建上下文、bean</p></li><li><p>刷新上下文</p></li><li><p>结束，</p><p>其中穿插了很多监听器的动作，并且很多逻辑都是靠各种监听器的实现类执行的。</p></li></ul><pre><code class="java">/** * Run the Spring application, creating and refreshing a new * {@link ApplicationContext}. * @param args the application arguments (usually passed from a Java main method) * @return a running {@link ApplicationContext} */public ConfigurableApplicationContext run(String... args) {   //开启时钟计时   StopWatch stopWatch = new StopWatch();   stopWatch.start();   //spirng 上下文   ConfigurableApplicationContext context = null;   //启动异常报告容器   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();   //开启设置，让系统模拟不存在io设备   configureHeadlessProperty();   // 3.1 初始化SpringApplicationRunListener 监听器，并进行封装   SpringApplicationRunListeners listeners = getRunListeners(args);   listeners.starting();   try {      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);     //3.2 Environment 的准备       ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);      configureIgnoreBeanInfo(environment);      Banner printedBanner = printBanner(environment); // 打印标语 彩蛋     //3.3 创建上下文实例      context = createApplicationContext();     //异常播报器，默认有org.springframework.boot.diagnostics.FailureAnalyzers      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,            new Class[] { ConfigurableApplicationContext.class }, context);     //3.4 容器初始化      prepareContext(context, environment, listeners, applicationArguments, printedBanner);     //3.5 刷新上下文容器       refreshContext(context);     //给实现类留的钩子，这里是一个空方法。      afterRefresh(context, applicationArguments);      stopWatch.stop();      if (this.logStartupInfo) {         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);      }      listeners.started(context);      callRunners(context, applicationArguments);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, listeners);      throw new IllegalStateException(ex);   }   try {      listeners.running(context);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, null);      throw new IllegalStateException(ex);   }   return context;}</code></pre><h3 id="3-1-SpringApplicationRunListener-的使用"><a href="#3-1-SpringApplicationRunListener-的使用" class="headerlink" title="3.1 SpringApplicationRunListener 的使用"></a>3.1 SpringApplicationRunListener 的使用</h3><p>首先通过getSpringFactoriesInstances 获取到所有实现SpringApplicationRunListener  接口的实例，默认情况下该接口的实现类只有 EventPublishingRunListener  他的主要作用是作为springboot 的一个广播器</p><pre><code class="java">public interface SpringApplicationRunListener {  /**EventPublishingRunListener 前期采用 SimpleApplicationEventMulticaster.multicastEvent(ApplicationEvent) 进行广播  **/   default void starting() {}    default void environmentPrepared(ConfigurableEnvironment environment) {}   default void contextPrepared(ConfigurableApplicationContext context) {}   default void contextLoaded(ConfigurableApplicationContext context) {}  /**  EventPublishingRunListener 后期采用 context.publishEvent(ApplicationEvent)  **/   default void started(ConfigurableApplicationContext context) {}   default void running(ConfigurableApplicationContext context) {}   default void failed(ConfigurableApplicationContext context, Throwable exception) {}}</code></pre><h3 id="3-2-prepareEnvironment"><a href="#3-2-prepareEnvironment" class="headerlink" title="3.2 prepareEnvironment"></a>3.2 prepareEnvironment</h3><p>一般在写业务代码时使用的都是只读类型的接口<code>Environment</code>，该接口是对运行程序环境的抽象，是保存系统配置的中心，而在启动过程中使用的则是可编辑的<code>ConfigurableEnvironment</code>。接口的UML类图如下，提供了合并父环境、添加active profile以及一些设置解析配置文件方式的接口。</p><p>其中一个比较重要的方法<code>MutablePropertySources getPropertySources();</code>，该方法返回一个可编辑的<code>PropertySources</code>，如果有在启动阶段自定义环境的PropertySources的需求，就可以通过该方法设置。</p><pre><code class="java">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,      ApplicationArguments applicationArguments) {   // Create and configure the environment  //根据不同环境不同的Enviroment （StandardServletEnvironment，StandardReactiveWebEnvironment，StandardEnvironment）   ConfigurableEnvironment environment = getOrCreateEnvironment();  //填充启动类参数到enviroment 对象   configureEnvironment(environment, applicationArguments.getSourceArgs());  //更新参数  ConfigurationPropertySources.attach(environment);  //发布事件   listeners.environmentPrepared(environment);  //绑定主类   bindToSpringApplication(environment);   if (!this.isCustomEnvironment) {//转换environment的类型，但这里应该类型和deduce的相同不用转换      environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,            deduceEnvironmentClass());   }  //将现有参数有封装成proertySources   ConfigurationPropertySources.attach(environment);   return environment;}</code></pre><h3 id="3-3-创建springApplicationContext-上下文"><a href="#3-3-创建springApplicationContext-上下文" class="headerlink" title="3.3  创建springApplicationContext 上下文"></a>3.3  创建springApplicationContext 上下文</h3><img src="/wiki/spring/springboot/springboot%20启动流程分析/springApplicationContext.webp" title="[启动流程分析]"><p>继承的三个父类接口里，<code>Closeable</code>提供了关闭时资源释放的接口，<code>Lifecycle</code>是提供对生命周期控制的接口(start\stop)以及查询当前运行状态的接口，<code>ApplicationContext</code>则是配置上下文的中心配置接口，继承了其他很多配置接口，其本身提供查询诸如id、应用程序名等上下文档案信息的只读接口，以及构建自动装配bean的工厂。</p><ul><li>EnvironmentCapable</li></ul><p>提供Environment接口。</p><ul><li>MessageSource</li></ul><p>国际化资源接口。</p><ul><li>ApplicationEventPublisher</li></ul><p>事件发布器。</p><ul><li>ResourcePatternResolver</li></ul><p>资源加载器。</p><ul><li>HierarchicalBeanFactory、ListableBeanFactory</li></ul><p>这两个都继承了bean容器的根接口<code>BeanFactory</code></p><p>简而言之就是根据Web容器类型的不同来创建不用的上下文实例。</p><h3 id="3-4-上下文初始化"><a href="#3-4-上下文初始化" class="headerlink" title="3.4 上下文初始化"></a>3.4 上下文初始化</h3><pre><code class="java">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,      SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {  //绑定环境   context.setEnvironment(environment);  //如果application有设置beanNameGenerator、resourceLoader就将其注入到上下文中，并将转换工具也注入到上下文中  postProcessApplicationContext(context);  //调用初始化的切面   applyInitializers(context);  //发布ApplicationContextInitializedEvent事件   listeners.contextPrepared(context);  //日志   if (this.logStartupInfo) {      logStartupInfo(context.getParent() == null);      logStartupProfileInfo(context);   }   // Add boot specific singleton beans   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();   beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);   if (printedBanner != null) {      beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);   }   if (beanFactory instanceof DefaultListableBeanFactory) {     //如果bean名相同的话是否允许覆盖，默认为false，相同会抛出异常      ((DefaultListableBeanFactory) beanFactory)            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);   }   if (this.lazyInitialization) {      context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());   }   // Load the sources  // 这里获取到的是BootstrapImportSelectorConfiguration这个class，而不是自己写的启动来，这个class是在之前注册的BootstrapApplicationListener的监听方法中注入的   Set&lt;Object&gt; sources = getAllSources();   Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);  //加载sources 到上下文中   load(context, sources.toArray(new Object[0]));  //发布ApplicationPreparedEvent事件   listeners.contextLoaded(context);}</code></pre><h3 id="3-5-刷新上下文"><a href="#3-5-刷新上下文" class="headerlink" title="3.5 刷新上下文"></a>3.5 刷新上下文</h3><pre><code>AbstractApplicationContext</code></pre><pre><code class="java">public void refresh() throws BeansException, IllegalStateException {    synchronized (this.startupShutdownMonitor) {        //记录启动时间、状态，web容器初始化其property，复制listener        prepareRefresh();        //这里返回的是context的BeanFactory        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        //beanFactory注入一些标准组件，例如ApplicationContextAwareProcessor，ClassLoader等        prepareBeanFactory(beanFactory);        try {            //给实现类留的一个钩子，例如注入BeanPostProcessors，这里是个空方法            postProcessBeanFactory(beanFactory);            // 调用切面方法            invokeBeanFactoryPostProcessors(beanFactory);            // 注册切面bean            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // bean工厂注册一个key为applicationEventMulticaster的广播器            initApplicationEventMulticaster();            // 给实现类留的一钩子，可以执行其他refresh的工作，这里是个空方法            onRefresh();            // 将listener注册到广播器中            registerListeners();            // 实例化未实例化的bean            finishBeanFactoryInitialization(beanFactory);            // 清理缓存，注入DefaultLifecycleProcessor，发布ContextRefreshedEvent            finishRefresh();        }        catch (BeansException ex) {            if (logger.isWarnEnabled()) {                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            }            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &#39;active&#39; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        }        finally {            // Reset common introspection caches in Spring&#39;s core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();        }    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><p><a href="https://www.jianshu.com/p/a46392c5cc50" rel="external nofollow noopener noreferrer" target="_blank">springboot启动的流程图</a></p></li><li><p><a href="https://blog.csdn.net/zlc3323/article/details/100137222?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" rel="external nofollow noopener noreferrer" target="_blank">能说下springboot启动原理吗</a></p></li><li><p><a href="https://www.jianshu.com/p/603d125f21b3" rel="external nofollow noopener noreferrer" target="_blank">Springboot 启动过程分析</a></p></li><li><p><a href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e" rel="external nofollow noopener noreferrer" target="_blank">springboot结构图</a></p><p>​</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>活用linux命令:netstat</title>
      <link href="/wiki/linux/shell/%E6%B4%BB%E7%94%A8linux%E5%91%BD%E4%BB%A4-netstat/"/>
      <url>/wiki/linux/shell/%E6%B4%BB%E7%94%A8linux%E5%91%BD%E4%BB%A4-netstat/</url>
      
        <content type="html"><![CDATA[<p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。  </p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code>$ netstat [-acCeFghilMnNoprstuvVwx] [-A&lt;网络类型&gt;][--ip]</code></pre><h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p> netstat 用于显示IP，TCP，UDP和ICMP协议相关的统计数据，一般用于检验本机端口的网络连接情况。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>-a或–all</td><td>显示所有连线中的Socket</td></tr><tr><td>-A&lt;网络类型&gt;或–&lt;网络类型&gt;</td><td>列出该网络类型连线中的相关地址</td></tr><tr><td>-c或–continuous</td><td>持续列出网络状态</td></tr><tr><td>-C或–cache</td><td>显示路由器配置的快取信息</td></tr><tr><td>-e或–extend</td><td>显示网络其他相关信息</td></tr><tr><td>-F或–fib</td><td>显示FIB</td></tr><tr><td>-g或–groups</td><td>显示多重广播功能群组组员名单</td></tr><tr><td>-h或–help</td><td>在线帮助</td></tr><tr><td>-i或–interfaces</td><td>显示网络界面信息表单</td></tr><tr><td>-l或–listening</td><td>显示监控中的服务器的Socket</td></tr><tr><td>-M或–masquerade</td><td>显示伪装的网络连线</td></tr><tr><td>-n或–numeric</td><td>直接使用IP地址，而不通过域名服务器</td></tr><tr><td>-N或–netlink或–symbolic</td><td>显示网络硬件外围设备的符号连接名称</td></tr><tr><td>-o或–timers</td><td>显示计时器</td></tr><tr><td>-p或–programs</td><td>显示正在使用Socket的程序识别码和程序名称</td></tr><tr><td>-r或–route</td><td>显示Routing Table</td></tr><tr><td>-s或–statistice</td><td>显示网络工作信息统计表</td></tr><tr><td>-t或–tcp</td><td>显示TCP传输协议的连线状况</td></tr><tr><td>-u或–udp</td><td>显示UDP传输协议的连线状况</td></tr><tr><td>-v或–verbose</td><td>显示指令执行过程</td></tr><tr><td>-V或–version</td><td>显示版本信息</td></tr><tr><td>-w或–raw</td><td>显示RAW传输协议的连线状况</td></tr><tr><td>-x或–unix</td><td>此参数的效果和指定”-A unix”参数相同</td></tr><tr><td>–ip或–inet</td><td>此参数的效果和指定”-A inet”参数相同</td></tr></tbody></table><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="无参数使用"><a href="#无参数使用" class="headerlink" title="无参数使用"></a>无参数使用</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://yelog.org/2017/01/10/linux-command%EF%BC%8841%EF%BC%89-netstat/" rel="external nofollow noopener noreferrer" target="_blank">每天一个linux命令（41）: netstat</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/wiki/java/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/wiki/java/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h2><img src="/wiki/java/JVM内存模型/java内存模型.png" title="[jvm 内存模型]"><h2 id="各组件说明"><a href="#各组件说明" class="headerlink" title="各组件说明"></a>各组件说明</h2><h3 id="1-线程私有"><a href="#1-线程私有" class="headerlink" title="1.线程私有"></a>1.线程私有</h3><h4 id="1-1虚拟机栈和本地方法栈"><a href="#1-1虚拟机栈和本地方法栈" class="headerlink" title="1.1虚拟机栈和本地方法栈"></a>1.1虚拟机栈和本地方法栈</h4><p>线程私有，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。Java虚拟机栈是由一个个栈帧组成，线程在执行一个方法时，便会向栈中放入一个栈帧，每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法出口信息。局部变量表主要存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><ul><li>StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛StackOverFlowError异常。</li><li>OutOfMemoryError：若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>　　Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p>本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><h4 id="1-2程序计数器"><a href="#1-2程序计数器" class="headerlink" title="1.2程序计数器"></a>1.2程序计数器</h4><p>java虚拟机的多线程是通过线程轮流切换并分配CPU的时间片的方式实现的，因此在任何时刻一个处理器（如果是多核处理器，则只是一个核）都只会处理一个线程，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，因此这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><strong>注意 ：</strong>程序计数器是唯不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="2-线程共享"><a href="#2-线程共享" class="headerlink" title="2.线程共享"></a>2.线程共享</h3><h4 id="2-1-堆区"><a href="#2-1-堆区" class="headerlink" title="2.1 堆区"></a>2.1 堆区</h4><p>Java堆是java应用程序关系最密切的内存空间，几乎所有对象都存放到其中，并且java堆完全是自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显示的释放。</p><p>根据垃圾回收机制不同，java堆有可能拥有不同的结构。最为常见的就是将整个java堆分为新生代和老年代。其中新生代存放新声的对象或者年龄不大的对象，老年代则存放老年对象。</p><p>新生代分为eden区、s0区、s1区，s0区和s1区被称为from和to区域，他们是两块大小相等并且可以互换角色的空间。</p><p>绝大多数情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存货，则会进入s0或者s1区，之后每经过一次新生代回收，如果对象存活则它的年纪就加1，</p><p>当对象达到一定年龄后，进入老年代。</p><h4 id="2-2-方法区"><a href="#2-2-方法区" class="headerlink" title="2.2 方法区"></a>2.2 方法区</h4><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/aiqiqi/p/10770864.html#_label1" rel="external nofollow noopener noreferrer" target="_blank">JVM内存模型和面试题解析</a></li><li><a href="https://www.processon.com/view/5e2ef355e4b04579e40d5875" rel="external nofollow noopener noreferrer" target="_blank">JVM内存模型图</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springMvc处理流程</title>
      <link href="/wiki/spring/springmvc/springMvc%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
      <url>/wiki/spring/springmvc/springMvc%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-mvc相关组件及介绍"><a href="#spring-mvc相关组件及介绍" class="headerlink" title="spring mvc相关组件及介绍"></a>spring mvc相关组件及介绍</h1><ul><li><h4 id="DispatchServlet"><a href="#DispatchServlet" class="headerlink" title="DispatchServlet"></a>DispatchServlet</h4>java开发在经历了超级servlet阶段后，开始为servlet减负的尝试，MVC结构把servlet的工作分为frontController与Page Controller，前着进行必要请求的转发，后者负责具体的业务逻辑处理，DispathServlet就是frontController的角色，负责接收web请求建立连接，然后调用合适的处理类获得结果，返回。</li><li><h4 id="handlerMapping"><a href="#handlerMapping" class="headerlink" title="handlerMapping"></a>handlerMapping</h4>在DispatchServlet接收到客户端的请求之后，通过handlerMapping匹配到具体的处理类（handler），handler代表所有的次级控制类，除了我们常用的controller意外还有第三方WEB开发框架中的Page Controller组件。<br>handerMapping类的实现类有多个：</li></ul><ol><li>SimpleUrlHandlerMapping</li><li>ControllerClassnameHandlerMapping</li><li>DefaultAnnotationHandlerMapping(基于注解的配置方式)<br>这些hangdlerMapping一个dispatchSerlet中可以配置多个，他们通过实现的Ordered接口按照序列优先级执行</li></ol><ul><li><h4 id="Handler（Controller）"><a href="#Handler（Controller）" class="headerlink" title="Handler（Controller）"></a>Handler（Controller）</h4>在SpirngMvc中，任何可以用于Web请求处理的对象统称为handler，Controller是Handler中的一个特殊类型</li><li><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4>主要工作只是调用这个HandlerAdaptor“认识”的Handler的web请求处理方法，然后将处理结果转换为DispatcherServlet统一使用的ModelAndView就行。</li><li><h4 id="HanderExceptionResolver"><a href="#HanderExceptionResolver" class="headerlink" title="HanderExceptionResolver"></a>HanderExceptionResolver</h4>提供统一的异常处理方式，让handler的throws Exception看起来更加“理直气壮”</li></ul><h3 id="spring-mvc各组件交互流程"><a href="#spring-mvc各组件交互流程" class="headerlink" title="spring mvc各组件交互流程"></a>spring mvc各组件交互流程</h3><ul><li><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="/wiki/spring/springmvc/springMvc处理流程/springMvc处理流程图.png" title="[spring MVC 时序图]"></li><li><h4 id="步骤详细描述"><a href="#步骤详细描述" class="headerlink" title="步骤详细描述"></a>步骤详细描述</h4></li></ul><ol><li>DispatcherServlet 接收到满足web.xml配置的Http请求，daspatcherServlet通过handlerAdapter从HandlerMapping获取对应该请求得处理器</li><li>Handler 通过handlerRequest(request,reponse)处理具体的请求，然后返回处理结果ModelAndView</li><li>DispatcherServlet接收到ModelAndView后通过调用ViewResolve 组装View，返回View<br>4.DispatcherServlet返回处理结果</li></ol><h3 id="相关技术字典"><a href="#相关技术字典" class="headerlink" title="相关技术字典"></a>相关技术字典</h3><ol><li><h4 id="Restful-web-请求风格"><a href="#Restful-web-请求风格" class="headerlink" title="Restful web 请求风格"></a>Restful web 请求风格</h4> 采用Restful 架构的web请求分割的原则</li></ol><ul><li>每一个URI代表一种资源（URI中应该全是名词，动作操作全部传给Http协议）</li><li>客户端和服务端之间，传递这种资源的某种变现层</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”</li></ul><ol start="2"><li><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4> HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html" rel="external nofollow noopener noreferrer" target="_blank">理解RESTful架构</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP 协议入门</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springmvc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pageHelper的使用</title>
      <link href="/wiki/spring/springmvc/pageHelp%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/wiki/spring/springmvc/pageHelp%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pageHelper的使用"><a href="#pageHelper的使用" class="headerlink" title="pageHelper的使用"></a>pageHelper的使用</h1><h2 id="pageHelper"><a href="#pageHelper" class="headerlink" title="pageHelper"></a>pageHelper</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h3 id="第一种，RowBounds方式的调用"><a href="#第一种，RowBounds方式的调用" class="headerlink" title="第一种，RowBounds方式的调用"></a>第一种，RowBounds方式的调用</h3><pre><code>List&lt;Country&gt; list = sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(0, 10));</code></pre><h3 id="第二种，Mapper接口方式的调用，推荐这种使用方式。"><a href="#第二种，Mapper接口方式的调用，推荐这种使用方式。" class="headerlink" title="第二种，Mapper接口方式的调用，推荐这种使用方式。"></a>第二种，Mapper接口方式的调用，推荐这种使用方式。</h3><pre><code>PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);</code></pre><h3 id="第三种，Mapper接口方式的调用，推荐这种使用方式。"><a href="#第三种，Mapper接口方式的调用，推荐这种使用方式。" class="headerlink" title="第三种，Mapper接口方式的调用，推荐这种使用方式。"></a>第三种，Mapper接口方式的调用，推荐这种使用方式。</h3><pre><code>PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);</code></pre><h3 id="第四种，参数方法调用"><a href="#第四种，参数方法调用" class="headerlink" title="第四种，参数方法调用"></a>第四种，参数方法调用</h3><pre><code>//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper {    List&lt;Country&gt; selectByPageNumSize(            @Param(&quot;user&quot;) User user,            @Param(&quot;pageNum&quot;) int pageNum,            @Param(&quot;pageSize&quot;) int pageSize);}//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10);</code></pre><h3 id="第五种，参数对象"><a href="#第五种，参数对象" class="headerlink" title="第五种，参数对象"></a>第五种，参数对象</h3><p>如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页<br>有如下 User 对象</p><pre><code>public class User {    //其他fields    //下面两个参数名和 params 配置的名字一致    private Integer pageNum;    private Integer pageSize;}//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper {    List&lt;Country&gt; selectByPageNumSize(User user);}//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);</code></pre><h3 id="第六种，ISelect-接口方式"><a href="#第六种，ISelect-接口方式" class="headerlink" title="第六种，ISelect 接口方式"></a>第六种，ISelect 接口方式</h3><pre><code>//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() {    @Override    public void doSelect() {        countryMapper.selectGroupBy();    }});//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() {    @Override    public void doSelect() {        countryMapper.selectGroupBy();    }});//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() {    @Override    public void doSelect() {        countryMapper.selectLike(country);    }});//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country));</code></pre><blockquote><ul><li>​</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java2 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
