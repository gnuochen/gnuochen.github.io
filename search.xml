<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java8新特性</title>
      <link href="/wiki/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/wiki/java/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一-语言新特性"><a href="#一-语言新特性" class="headerlink" title="一.语言新特性"></a>一.语言新特性</h2><h3 id="1-接口的默认方法"><a href="#1-接口的默认方法" class="headerlink" title="1.接口的默认方法"></a>1.接口的默认方法</h3><p>用default关键字可以在接口实现一个非抽象方法，也称为扩展方法</p><pre><code class="java">interface Formula {    double calculate(int a);    default double sqrt(int a) {        return Math.sqrt(a);    }}</code></pre><pre><code class="java">Formula formula = new Formula() {    @Override    public double calculate(int a) {        return sqrt(a * 100);    }};formula.calculate(100);     // 100.0formula.sqrt(16);           // 4.0</code></pre><p>打破了java单继承的限制，可以在接口实现扩展方法然后多继承。</p><h3 id="2-lamda表达式"><a href="#2-lamda表达式" class="headerlink" title="2.lamda表达式"></a>2.lamda表达式</h3><p>以排序为例</p><pre><code class="java">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</code></pre><p>作为之前Comparator 匿名的间接写法</p><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;String&gt;() {    @Override    public int compare(String a, String b) {        return b.compareTo(a);    }});</code></pre><p>通过lamda表达式可以简化很多之前java的写法，下面的函数式就是</p><h4 id="2-1-函数式接口"><a href="#2-1-函数式接口" class="headerlink" title="2.1 函数式接口"></a>2.1 函数式接口</h4><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><pre><code class="java">@FunctionalInterfaceinterface Converter&lt;F, T&gt; {    T convert(F from);}Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(&quot;123&quot;);System.out.println(converted);    // 123</code></pre><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><h4 id="2-2-方法与构造函数引用"><a href="#2-2-方法与构造函数引用" class="headerlink" title="2.2 方法与构造函数引用"></a>2.2 方法与构造函数引用</h4><p>前一节中的代码还可以通过静态方法引用来表示：</p><pre><code class="java">Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(&quot;123&quot;);System.out.println(converted);   // 123</code></pre><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><pre><code class="java"> converter = something::startsWith;String converted = converter.convert(&quot;Java&quot;);System.out.println(converted);    // &quot;J&quot;</code></pre><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><pre><code class="java">class Person {    String firstName;    String lastName;    Person() {}    Person(String firstName, String lastName) {        this.firstName = firstName;        this.lastName = lastName;    }}</code></pre><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><pre><code class="java">interface PersonFactory&lt;P extends Person&gt; {    P create(String firstName, String lastName);}</code></pre><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p><pre><code class="java">PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</code></pre><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p><h4 id="2-3-lambda作用域"><a href="#2-3-lambda作用域" class="headerlink" title="2.3.lambda作用域"></a>2.3.lambda作用域</h4><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p><h5 id="2-3-1-访问局部变量"><a href="#2-3-1-访问局部变量" class="headerlink" title="2.3.1.访问局部变量"></a>2.3.1.访问局部变量</h5><p>我们可以直接在lambda表达式中访问外层的局部变量：</p><pre><code class="java">final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2);     // 3</code></pre><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><pre><code class="java">int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2);     // 3</code></pre><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><pre><code class="java">int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);num = 3;</code></pre><p>在lambda表达式中试图修改num同样是不允许的。</p><h5 id="2-3-2-访问对象字段与静态变量"><a href="#2-3-2-访问对象字段与静态变量" class="headerlink" title="2.3.2.访问对象字段与静态变量"></a>2.3.2.访问对象字段与静态变量</h5><p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p><p>class Lambda4 {</p><pre><code class="java">static int outerStaticNum;int outerNum;void testScopes() {    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {        outerNum = 23;        return String.valueOf(from);    };    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {        outerStaticNum = 72;        return String.valueOf(from);    };}</code></pre><p>}</p><h5 id="2-3-3-访问接口的默认方法"><a href="#2-3-3-访问接口的默认方法" class="headerlink" title="2.3.3.访问接口的默认方法"></a>2.3.3.访问接口的默认方法</h5><p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：</p><pre><code>Formula formula = (a) -&gt; sqrt( a * 100);Built-in Functional Interfaces</code></pre><p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h6 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a><strong>Predicate接口</strong></h6><p>Predicate 接口只有一个参数，返回<strong>boolean</strong>类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p><pre><code class="java">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test(&quot;foo&quot;);              // truepredicate.negate().test(&quot;foo&quot;);     // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</code></pre><h6 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a><strong>Function 接口</strong></h6><p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p><pre><code class="java">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply(&quot;123&quot;);     // &quot;123&quot;</code></pre><h6 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a><strong>Supplier 接口</strong></h6><p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p><pre><code class="java">Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get();   // new Person</code></pre><h6 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a><strong>Consumer 接口</strong></h6><p>Consumer 接口表示执行在单个参数上的操作。</p><pre><code class="java">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</code></pre><h6 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a><strong>Comparator 接口</strong></h6><p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><pre><code class="java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);comparator.compare(p1, p2);             // &gt; 0comparator.reversed().compare(p1, p2);  // &lt; 0</code></pre><h6 id="Optional-接口"><a href="#Optional-接口" class="headerlink" title="Optional 接口"></a><strong>Optional 接口</strong></h6><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><pre><code class="java">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);optional.isPresent();           // trueoptional.get();                 // &quot;bam&quot;optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</code></pre><h6 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a><strong>Stream 接口</strong></h6><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><pre><code class="java">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add(&quot;ddd2&quot;);stringCollection.add(&quot;aaa2&quot;);stringCollection.add(&quot;bbb1&quot;);stringCollection.add(&quot;aaa1&quot;);stringCollection.add(&quot;bbb3&quot;);stringCollection.add(&quot;ccc&quot;);stringCollection.add(&quot;bbb2&quot;);stringCollection.add(&quot;ddd1&quot;);</code></pre><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><p><strong>Filter 过滤</strong></p><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><pre><code class="java">stringCollection    .stream()    .filter((s) -&gt; s.startsWith(&quot;a&quot;))    .forEach(System.out::println);// &quot;aaa2&quot;, &quot;aaa1&quot;</code></pre><p><strong>Sort 排序</strong></p><p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p><pre><code class="java">stringCollection    .stream()    .sorted()    .filter((s) -&gt; s.startsWith(&quot;a&quot;))    .forEach(System.out::println);// &quot;aaa1&quot;, &quot;aaa2&quot;</code></pre><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的。</p><pre><code class="java">System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</code></pre><p><strong>Map 映射</strong></p><p>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><pre><code class="java">stringCollection    .stream()    .map(String::toUpperCase)    .sorted((a, b) -&gt; b.compareTo(a))    .forEach(System.out::println);// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</code></pre><p><strong>Match 匹配</strong></p><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p><pre><code class="java">boolean anyStartsWithA =     stringCollection        .stream()        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));System.out.println(anyStartsWithA);      // trueboolean allStartsWithA =     stringCollection        .stream()        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));System.out.println(allStartsWithA);      // falseboolean noneStartsWithZ =     stringCollection        .stream()        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));System.out.println(noneStartsWithZ);      // true</code></pre><p><strong>Count 计数</strong></p><p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p><pre><code class="java">long startsWithB =     stringCollection        .stream()        .filter((s) -&gt; s.startsWith(&quot;b&quot;))        .count();System.out.println(startsWithB);    // 3</code></pre><p><strong>Reduce 规约</strong></p><p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p><pre><code class="java">Optional&lt;String&gt; reduced =    stringCollection        .stream()        .sorted()        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);reduced.ifPresent(System.out::println);// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</code></pre><p><strong>并行Streams</strong></p><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表</p><pre><code class="java">int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) {    UUID uuid = UUID.randomUUID();    values.add(uuid.toString());}</code></pre><p>然后我们计算一下排序这个Stream要耗时多久，</p><p><strong>串行排序：</strong></p><pre><code class="java">long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));</code></pre><p>// 串行耗时: 899 ms</p><p><strong>并行排序：</strong></p><pre><code class="java">long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));</code></pre><p>// 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p><p><strong>Map</strong></p><p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p><pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) {    map.putIfAbsent(i, &quot;val&quot; + i);}map.forEach((id, val) -&gt; System.out.println(val));</code></pre><p>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p><p>下面的例子展示了map上的其他有用的函数：</p><pre><code class="java">map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3);             // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9);     // falsemap.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);map.containsKey(23);    // truemap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);map.get(3);             // val33</code></pre><p>接下来展示如何在Map里删除一个键值全都匹配的项</p><pre><code class="java">map.remove(3, &quot;val3&quot;);map.get(3);             // val33map.remove(3, &quot;val33&quot;);map.get(3);             // null</code></pre><p>另外一个有用的方法</p><pre><code class="java">map.getOrDefault(42, &quot;not found&quot;);  // not found</code></pre><p>对Map的元素做合并也变得很容易了：</p><pre><code class="java">map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9);             // val9map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9);             // val9concat</code></pre><p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h3 id="3-annotation注解"><a href="#3-annotation注解" class="headerlink" title="3.annotation注解"></a>3.annotation注解</h3><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><pre><code class="java">@interface Hints {    Hint[] value();}@Repeatable(Hints.class)@interface Hint {    String value();}</code></pre><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p><p>例 1: 使用包装类当容器来存多个注解（老方法）</p><pre><code class="java">@Hints({@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)})class Person {}</code></pre><p>例 2：使用多重注解（新方法）</p><pre><code class="java">@Hint(&quot;hint1&quot;)@Hint(&quot;hint2&quot;)class Person {}</code></pre><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p><pre><code class="java">Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint);                   // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length);  // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length);          // 2</code></pre><p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：</p><pre><code class="java">@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})@interface MyAnnotation {}</code></pre><h2 id="二-Java编译器的新特性"><a href="#二-Java编译器的新特性" class="headerlink" title="二. Java编译器的新特性"></a>二. Java编译器的新特性</h2><h3 id="1-参数名称"><a href="#1-参数名称" class="headerlink" title="1.参数名称"></a>1.参数名称</h3><p>为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如<a href="https://github.com/paul-hammant/paranamer" rel="external nofollow noopener noreferrer" target="_blank">Paranamer liberary</a>。Java 8终于将这个特性规范化，在语言层面（使用反射API和<strong>Parameter.getName()方法</strong>）和字节码层面（使用新的<strong>javac</strong>编译器以及<strong>-parameters</strong>参数）提供支持。</p><pre><code class="java">package com.javacodegeeks.java8.parameter.names;import java.lang.reflect.Method;import java.lang.reflect.Parameter;public class ParameterNames {    public static void main(String[] args) throws Exception {        Method method = ParameterNames.class.getMethod( &quot;main&quot;, String[].class );        for( final Parameter parameter: method.getParameters() ) {            System.out.println( &quot;Parameter: &quot; + parameter.getName() );        }    }}</code></pre><p>在Java 8中这个特性是默认关闭的，因此如果不带<strong>-parameters</strong>参数编译上述代码并运行，则会输出如下结果：</p><pre><code class="java">Parameter: arg0</code></pre><p>如果带<strong>-parameters</strong>参数，则会输出如下结果（正确的结果）：</p><pre><code class="java">Parameter: args</code></pre><p>如果你使用Maven进行项目管理，则可以在<strong>maven-compiler-plugin</strong>编译器的配置项中配置<strong>-parameters</strong>参数：</p><pre><code class="java">&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;version&gt;3.1&lt;/version&gt;    &lt;configuration&gt;        &lt;compilerArgument&gt;-parameters&lt;/compilerArgument&gt;        &lt;source&gt;1.8&lt;/source&gt;        &lt;target&gt;1.8&lt;/target&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><h2 id="三-java官方库的新特性"><a href="#三-java官方库的新特性" class="headerlink" title="三.java官方库的新特性"></a>三.java官方库的新特性</h2><h3 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h3><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h4 id="1-1Clock-时钟"><a href="#1-1Clock-时钟" class="headerlink" title="1.1Clock 时钟"></a>1.1<strong>Clock 时钟</strong></h4><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p><pre><code class="java">Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant);   // legacy java.util.Date</code></pre><h4 id="1-2Timezones-时区"><a href="#1-2Timezones-时区" class="headerlink" title="1.2Timezones 时区"></a>1.2<strong>Timezones 时区</strong></h4><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p><pre><code class="java">System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00]</code></pre><h4 id="1-3-LocalTime-本地时间"><a href="#1-3-LocalTime-本地时间" class="headerlink" title="1.3 LocalTime 本地时间"></a>1.3 <strong>LocalTime 本地时间</strong></h4><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p><pre><code class="java">LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2));  // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween);       // -3System.out.println(minutesBetween);     // -239</code></pre><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p><pre><code class="java">LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late);       // 23:59:59DateTimeFormatter germanFormatter =    DateTimeFormatter        .ofLocalizedTime(FormatStyle.SHORT)        .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);System.out.println(leetTime);   // 13:37</code></pre><h4 id="1-4-LocalDate-本地日期"><a href="#1-4-LocalDate-本地日期" class="headerlink" title="1.4 LocalDate 本地日期"></a>1.4 <strong>LocalDate 本地日期</strong></h4><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek);    // FRIDAY</code></pre><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p><pre><code class="java">DateTimeFormatter germanFormatter =    DateTimeFormatter        .ofLocalizedDate(FormatStyle.MEDIUM)        .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);System.out.println(xmas);   // 2014-12-24</code></pre><h4 id="1-5-LocalDateTime-本地日期时间"><a href="#1-5-LocalDateTime-本地日期时间" class="headerlink" title="1.5 LocalDateTime 本地日期时间"></a>1.5 <strong>LocalDateTime 本地日期时间</strong></h4><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p><pre><code>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek);      // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month);          // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay);    // 1439</code></pre><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p><pre><code>Instant instant = sylvester        .atZone(ZoneId.systemDefault())        .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</code></pre><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><pre><code>DateTimeFormatter formatter =    DateTimeFormatter        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);String string = formatter.format(parsed);System.out.println(string);     // Nov 03, 2014 - 07:13</code></pre><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><p>关于时间日期格式的详细信息：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdownload.java.net%2Fjdk8%2Fdocs%2Fapi%2Fjava%2Ftime%2Fformat%2FDateTimeFormatter.html" rel="external nofollow noopener noreferrer" target="_blank">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p><h3 id="2-Optional"><a href="#2-Optional" class="headerlink" title="2. Optional"></a>2. Optional</h3><p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了Optionals类来解决NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。</p><p>Optional仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考Java 8官方文档了解更多细节。</p><p>接下来看一点使用Optional的例子：可能为空的值或者某个类型的值：</p><pre><code class="java">Optional&lt; String &gt; fullName = Optional.ofNullable( null );System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</code></pre><p>如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；orElseGet()方法，Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的Opetional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。</p><p>上述代码的输出结果如下：</p><pre><code class="java">Full Name is set? falseFull Name: [none]Hey Stranger!</code></pre><p>再看下另一个简单的例子：</p><pre><code class="java">Optional&lt; String &gt; firstName = Optional.of( &quot;Tom&quot; );System.out.println( &quot;First Name is set? &quot; + firstName.isPresent() );        System.out.println( &quot;First Name: &quot; + firstName.orElseGet( () -&gt; &quot;[none]&quot; ) ); System.out.println( firstName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );System.out.println();</code></pre><p>这个例子的输出是：</p><pre><code class="java">First Name is set? trueFirst Name: TomHey Tom!</code></pre><h3 id="3-Nashorn-JavaScript"><a href="#3-Nashorn-JavaScript" class="headerlink" title="3. Nashorn JavaScript"></a>3. Nashorn JavaScript</h3><p>Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下：</p><pre><code class="java">ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );System.out.println( engine.getClass().getName() );System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() { return 1; }; f() + 1;&quot; ) );</code></pre><pre><code class="java">jdk.nashorn.api.scripting.NashornScriptEngineResult: 2</code></pre><h3 id="4-Base64"><a href="#4-Base64" class="headerlink" title="4. Base64"></a>4. Base64</h3><p>对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下：</p><pre><code class="java">package com.javacodegeeks.java8.base64;import java.nio.charset.StandardCharsets;import java.util.Base64;public class Base64s {    public static void main(String[] args) {        final String text = &quot;Base64 finally in Java 8!&quot;;        final String encoded = Base64            .getEncoder()            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );        System.out.println( encoded );        final String decoded = new String(             Base64.getDecoder().decode( encoded ),            StandardCharsets.UTF_8 );        System.out.println( decoded );    }}</code></pre><pre><code class="java">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==Base64 finally in Java 8!</code></pre><p>新的Base64API也支持URL和MINE的编码解码。<br>(<strong>Base64.getUrlEncoder()</strong> / <strong>Base64.getUrlDecoder()</strong>, <strong>Base64.getMimeEncoder()</strong> / <strong>Base64.getMimeDecoder()</strong>)。</p><h3 id="5-并行数组"><a href="#5-并行数组" class="headerlink" title="5. 并行数组"></a>5. 并行数组</h3><p>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<strong>parallelSort()</strong>，可以显著加快多核机器上的数组排序。下面的例子论证了<strong>parallexXxx</strong>系列的方法：</p><pre><code class="java">package com.javacodegeeks.java8.parallel.arrays;import java.util.Arrays;import java.util.concurrent.ThreadLocalRandom;public class ParallelArrays {    public static void main( String[] args ) {        long[] arrayOfLong = new long [ 20000 ];                Arrays.parallelSetAll( arrayOfLong,             index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(             i -&gt; System.out.print( i + &quot; &quot; ) );        System.out.println();        Arrays.parallelSort( arrayOfLong );                Arrays.stream( arrayOfLong ).limit( 10 ).forEach(             i -&gt; System.out.print( i + &quot; &quot; ) );        System.out.println();    }}</code></pre><p>上述这些代码使用<strong>parallelSetAll()</strong>方法生成20000个随机数，然后使用<strong>parallelSort()</strong>方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p><pre><code>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 Sorted: 39 220 263 268 325 607 655 678 723 793</code></pre><h3 id="6-并发性"><a href="#6-并发性" class="headerlink" title="6.并发性"></a>6.并发性</h3><p>基于新增的lambda表达式和steam特性，为Java 8中为<strong>java.util.concurrent.ConcurrentHashMap</strong>类添加了新的方法来支持聚焦操作；另外，也为<strong>java.util.concurrentForkJoinPool</strong>类添加了新的方法来支持通用线程池操作（更多内容可以参考<a href="http://academy.javacodegeeks.com/course/java-concurrency-essentials/" rel="external nofollow noopener noreferrer" target="_blank">我们的并发编程课程</a>）。</p><p>Java 8还添加了新的<strong>java.util.concurrent.locks.StampedLock</strong>类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是<strong>java.util.concurrent.locks.ReadWriteLock</strong>的替代者）。</p><p>在<strong>java.util.concurrent.atomic</strong>包中也新增了不少工具类，列举如下：</p><ul><li><p>DoubleAccumulator</p></li><li><p>DoubleAdder</p></li><li><p>LongAccumulator</p></li><li><p>LongAdder</p><p>​</p></li></ul><h2 id="四-java工具"><a href="#四-java工具" class="headerlink" title="四.java工具"></a>四.java工具</h2><h3 id="1-Nashorn引擎：jjs"><a href="#1-Nashorn引擎：jjs" class="headerlink" title="1.Nashorn引擎：jjs"></a>1.Nashorn引擎：jjs</h3><p><strong>jjs</strong>是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。</p><h3 id="2-类依赖分析器：jdeps"><a href="#2-类依赖分析器：jdeps" class="headerlink" title="2.类依赖分析器：jdeps"></a>2.类依赖分析器：jdeps</h3><p><strong>jdeps</strong>是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以<strong>.class</strong>文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。</p><pre><code class="sh">jdeps org.springframework.core-3.0.5.RELEASE.jar</code></pre><pre><code class="c">org.springframework.core-3.0.5.RELEASE.jar -&gt; C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)      -&gt; java.io                                                  -&gt; java.lang                                                -&gt; java.lang.annotation                                     -&gt; java.lang.ref                                            -&gt; java.lang.reflect                                        -&gt; java.util                                                -&gt; java.util.concurrent                                     -&gt; org.apache.commons.logging                         not found      -&gt; org.springframework.asm                            not found      -&gt; org.springframework.asm.commons                    not found   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)      -&gt; java.lang                                                -&gt; java.lang.annotation                                     -&gt; java.lang.reflect                                        -&gt; java.util</code></pre><p>这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示”not found”.</p><h2 id="五-JVM的新特性"><a href="#五-JVM的新特性" class="headerlink" title="五. JVM的新特性"></a>五. JVM的新特性</h2><p>使用<strong>Metaspace</strong>（<a href="http://openjdk.java.net/jeps/122" rel="external nofollow noopener noreferrer" target="_blank">JEP 122</a>）代替持久代（<strong>PermGen</strong> space）。在JVM参数方面，使用<strong>-XX:MetaSpaceSize</strong>和<strong>-XX:MaxMetaspaceSize</strong>代替原来的<strong>-XX:PermSize</strong>和<strong>-XX:MaxPermSize</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/yczz/article/details/50896975" rel="external nofollow noopener noreferrer" target="_blank">Java 8的新特性—终极版</a></li><li><a href="https://www.jianshu.com/p/0bf8fe0f153b" rel="external nofollow noopener noreferrer" target="_blank">JAVA8十大新特性详解（精编）</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TreadLocal</title>
      <link href="/wiki/java/TreadLocal/"/>
      <url>/wiki/java/TreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>每一个线程（Thread）拥有一个自己独立的map 容器，用于保存变量，这样就可以在当前线程的任意地方获取保存的变量对象</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><pre><code class="java">public class ThreadLocal&lt;T&gt; {    private final int threadLocalHashCode = nextHashCode();    private static AtomicInteger nextHashCode = new AtomicInteger();    private static final int HASH_INCREMENT = 0x61c88647;    private static int nextHashCode() {        return nextHashCode.getAndAdd(HASH_INCREMENT);    }    protected T initialValue() {        return null;    }    public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {        return new SuppliedThreadLocal&lt;&gt;(supplier);    }    public ThreadLocal() {    }    public T get() {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings(&quot;unchecked&quot;)                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }    private T setInitialValue() {        T value = initialValue();        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);        return value;    }    public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }     public void remove() {         ThreadLocalMap m = getMap(Thread.currentThread());         if (m != null)             m.remove(this);     }    ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }    void createMap(Thread t, T firstValue) {        t.threadLocals = new ThreadLocalMap(this, firstValue);    }    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {        return new ThreadLocalMap(parentMap);    }    T childValue(T parentValue) {        throw new UnsupportedOperationException();    }    static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; {        private final Supplier&lt;? extends T&gt; supplier;        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) {            this.supplier = Objects.requireNonNull(supplier);        }        @Override        protected T initialValue() {            return supplier.get();        }    }    static class ThreadLocalMap {        // 。。。        }    }}</code></pre><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><p>可以发现ThreadLocal 的属性由两个变量 threadlocalHashCode（用于唯一表示当前ThreadLocal实例）,nextHashCode（用于下一个ThreadlocalHashCode的预计算），还有一个常量HASH_INCREMENT （用于计算HashCode）</p><pre><code>private final int threadLocalHashCode = nextHashCode();private static AtomicInteger nextHashCode = new AtomicInteger();private static final int HASH_INCREMENT = 0x61c88647;</code></pre><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><h4 id="2-1-set（）"><a href="#2-1-set（）" class="headerlink" title="2.1 set（）"></a>2.1 set（）</h4><pre><code class="java">/** * Sets the current thread&#39;s copy of this thread-local variable * to the specified value.  Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#39;s copy of *        this thread-local. */public void set(T value) {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);}</code></pre><pre><code class="java">publicclass Thread implements Runnable {    /* ThreadLocal values pertaining to this thread. This map is maintained     * by the ThreadLocal class. */    ThreadLocal.ThreadLocalMap threadLocals = null;}</code></pre><p>可见，是先取到当前线程的实例，再获取到ThreadLocalMap，然后set值</p><h4 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get()"></a>2.2 get()</h4><pre><code class="java">/** * Returns the value in the current thread&#39;s copy of this * thread-local variable.  If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread&#39;s value of this thread-local */public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        }    }    return setInitialValue();}</code></pre><p>与set方法相对应，获取到ThreadLocalMap中的方法</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="1-场景一，线程安全考虑"><a href="#1-场景一，线程安全考虑" class="headerlink" title="1.场景一，线程安全考虑"></a>1.场景一，线程安全考虑</h3><p>ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</p><p>所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。</p><p>对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。</p><pre><code class="java">public class TestThreadLocal2 {    public static ExecutorService threadPool = Executors.newFixedThreadPool(16);    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i &lt; 1000; i++) {            int finalI = i;            threadPool.submit(() -&gt; {                String data = new TestThreadLocal2().date(finalI);                System.out.println(data);            });        }        threadPool.shutdown();    }    private String date(int seconds){        Date date = new Date(1000 * seconds);        SimpleDateFormat dateFormat = ThreadSafeFormater.dateFormatThreadLocal.get();        return dateFormat.format(date);    }}class ThreadSafeFormater{    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;mm:ss&quot;));}</code></pre><h3 id="2-场景二，全局遍历，简化传参"><a href="#2-场景二，全局遍历，简化传参" class="headerlink" title="2.场景二，全局遍历，简化传参"></a>2.场景二，全局遍历，简化传参</h3><p>ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</p><pre><code class="java">public class TestThreaLocal3 {    public static void main(String[] args) {        User user = new User(&quot;jack&quot;);        new Service1().service1(user);    }}class Service1 {    public void service1(User user){        //给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。        UserContextHolder.holder.set(user);        new Service2().service2();    }}class Service2 {    public void service2(){        User user = UserContextHolder.holder.get();        System.out.println(&quot;service2拿到的用户:&quot;+user.name);        new Service3().service3();    }}class Service3 {    public void service3(){        User user = UserContextHolder.holder.get();        System.out.println(&quot;service3拿到的用户:&quot;+user.name);        //在整个流程执行完毕后，一定要执行remove        UserContextHolder.holder.remove();    }}class UserContextHolder {    //创建ThreadLocal保存User对象    public static ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();}class User {    String name;    public User(String name){        this.name = name;    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.iteye.com/topic/103804" rel="external nofollow noopener noreferrer" target="_blank">正确理解ThreadLocal</a></li><li><a href="https://www.cnblogs.com/zz-ksw/p/12684877.html" rel="external nofollow noopener noreferrer" target="_blank">ThreadLocal的应用场景</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/wiki/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/wiki/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设计模式的六大原则"><a href="#1-设计模式的六大原则" class="headerlink" title="1.设计模式的六大原则"></a>1.设计模式的六大原则</h2><ul><li><h3 id="开闭原则（Open-close-principle）"><a href="#开闭原则（Open-close-principle）" class="headerlink" title="开闭原则（Open close principle）"></a>开闭原则（Open close principle）</h3><p>软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p></li><li><h3 id="里氏替换原则（Liskov-substitution-principle）"><a href="#里氏替换原则（Liskov-substitution-principle）" class="headerlink" title="里氏替换原则（Liskov substitution principle）"></a>里氏替换原则（Liskov substitution principle）</h3><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 </p><p>1、里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</p><p>2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</p></li><li><h3 id="依赖倒转原则-（Dependence-iversion-principle）"><a href="#依赖倒转原则-（Dependence-iversion-principle）" class="headerlink" title="依赖倒转原则 （Dependence iversion principle）"></a>依赖倒转原则 （Dependence iversion principle）</h3><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p></li><li><h3 id="接口隔离原则（interface-segregation-principle）"><a href="#接口隔离原则（interface-segregation-principle）" class="headerlink" title="接口隔离原则（interface segregation principle）"></a>接口隔离原则（interface segregation principle）</h3><p>使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p></li><li><h3 id="迪米特原则-最少知道原则（Demeter-principle）"><a href="#迪米特原则-最少知道原则（Demeter-principle）" class="headerlink" title="迪米特原则-最少知道原则（Demeter principle）"></a>迪米特原则-最少知道原则（Demeter principle）</h3><p>　也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与”陌生人”说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p></li><li><h3 id="合成复用原则（composite-reuse-principle）"><a href="#合成复用原则（composite-reuse-principle）" class="headerlink" title="合成复用原则（composite reuse principle）"></a>合成复用原则（composite reuse principle）</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。、</p></li><li><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p> 对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。</p><p>​</p></li></ul><h2 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2.设计模式分类"></a>2.设计模式分类</h2><h3 id="2-1-总体来说设计模式分为三大类："><a href="#2-1-总体来说设计模式分为三大类：" class="headerlink" title="2.1 总体来说设计模式分为三大类："></a>2.1 总体来说设计模式分为三大类：</h3><p>​     （1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>​     （2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>​     （3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h3 id="2-2-一张图说明23种设计模式直接的关系"><a href="#2-2-一张图说明23种设计模式直接的关系" class="headerlink" title="2.2 一张图说明23种设计模式直接的关系"></a>2.2 一张图说明23种设计模式直接的关系</h3><img src="/wiki/design/设计模式总结/23种设计模式之间的关系.jpg" title="[23种设计模式之间的关系]"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/az4215/p/11489712.html" rel="external nofollow noopener noreferrer" target="_blank">设计模式六大原则</a></li><li><a href="https://blog.csdn.net/wanbf123/article/details/72528705" rel="external nofollow noopener noreferrer" target="_blank">设计模式结构图及设计原则</a></li><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/" rel="external nofollow noopener noreferrer" target="_blank">Graphic Design patterns</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>default</title>
      <link href="/wiki/database/sql/default/"/>
      <url>/wiki/database/sql/default/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
          <category> sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/wiki/algorithm/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/wiki/algorithm/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-算法的分类"><a href="#1-算法的分类" class="headerlink" title="1.算法的分类"></a>1.算法的分类</h2><img src="/wiki/algorithm/十大经典排序算法/排序算法分类.png" title="[排序算法分类]"><h2 id="2-各算法性能比较"><a href="#2-各算法性能比较" class="headerlink" title="2.各算法性能比较"></a>2.各算法性能比较</h2><table><thead><tr><th>排序方法</th><th>时间复杂度（平均）</th><th>时间复杂度（最差）</th><th>时间复杂度（最好）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog~2n)</td><td>O(n^2)</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(nlog~2n)</td><td>O(n)</td><td>稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计数排序</td><td>O(n+K)</td><td>O(n+K)</td><td>O(n+K)</td><td>O(n+K)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+K)</td><td>O(n^2)</td><td>O(n)</td><td>O(n+K)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>稳定</td></tr></tbody></table><p><em>相关概念</em></p><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p><p><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p></blockquote><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h2><h3 id="3-1-冒泡排序（Bubble-sort）"><a href="#3-1-冒泡排序（Bubble-sort）" class="headerlink" title="3.1 冒泡排序（Bubble sort）"></a>3.1 冒泡排序（Bubble sort）</h3><p>​    冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="3-1-1算法描述"><a href="#3-1-1算法描述" class="headerlink" title="3.1.1算法描述"></a>3.1.1算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h4 id="3-1-2-动图演示"><a href="#3-1-2-动图演示" class="headerlink" title="3.1.2 动图演示"></a>3.1.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/bubble_sort.gif" title="[冒泡排序]"><h4 id="3-1-3-代码实现"><a href="#3-1-3-代码实现" class="headerlink" title="3.1.3 代码实现"></a>3.1.3 代码实现</h4><pre><code class="java">    public static int[] bubbleSort(int[] array) {        if (array.length == 0)            return array;        for (int i = 0; i &lt; array.length; i++)            for (int j = 0; j &lt; array.length - 1 - i; j++)                if (array[j + 1] &lt; array[j]) {                    int temp = array[j + 1];                    array[j + 1] = array[j];                    array[j] = temp;                }        return array;    }</code></pre><h3 id="3-2-快速排序-quick-sort"><a href="#3-2-快速排序-quick-sort" class="headerlink" title="3.2 快速排序(quick sort)"></a>3.2 快速排序(quick sort)</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="3-2-1-算法描述"><a href="#3-2-1-算法描述" class="headerlink" title="3.2.1 算法描述"></a>3.2.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="3-2-2-动图演示"><a href="#3-2-2-动图演示" class="headerlink" title="3.2.2 动图演示"></a>3.2.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/quick_sort.gif" title="[快速排序]"><h4 id="3-2-3-代码实现"><a href="#3-2-3-代码实现" class="headerlink" title="3.2.3 代码实现"></a>3.2.3 代码实现</h4><pre><code class="java">//快速排序方法public static int[] QuickSort(int[] array, int start, int end) {    if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;    int smallIndex = partition(array, start, end);    if (smallIndex &gt; start)        QuickSort(array, start, smallIndex - 1);    if (smallIndex &lt; end)        QuickSort(array, smallIndex + 1, end);    return array;}// 快速排序算法——partitionpublic static int partition(int[] array, int start, int end) {    int pivot = (int) (start + Math.random() * (end - start + 1));    int smallIndex = start - 1;    swap(array, pivot, end);    for (int i = start; i &lt;= end; i++)        if (array[i] &lt;= array[end]) {            smallIndex++;            if (i &gt; smallIndex)                swap(array, i, smallIndex);        }    return smallIndex;}// 交换数组内两个元素public static void swap(int[] array, int i, int j) {    int temp = array[i];    array[i] = array[j];    array[j] = temp;}</code></pre><h3 id="3-3-插入排序（insertion-sort）"><a href="#3-3-插入排序（insertion-sort）" class="headerlink" title="3.3 插入排序（insertion sort）"></a>3.3 插入排序（insertion sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="3-3-1-算法描述"><a href="#3-3-1-算法描述" class="headerlink" title="3.3.1 算法描述"></a>3.3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-3-2-动图演示"><a href="#3-3-2-动图演示" class="headerlink" title="3.3.2 动图演示"></a>3.3.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/insertion_sort.gif" title="[插入排序]"><h4 id="3-3-3-代码实现"><a href="#3-3-3-代码实现" class="headerlink" title="3.3.3 代码实现"></a>3.3.3 代码实现</h4><pre><code class="java">public static int[] insertionSort(int[] array) {    if (array.length == 0)        return array;    int current;    for (int i = 0; i &lt; array.length - 1; i++) {        current = array[i + 1];        int preIndex = i;        while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) {            array[preIndex + 1] = array[preIndex];            preIndex--;        }        array[preIndex + 1] = current;    }    return array;}</code></pre><h3 id="3-4-希尔排序（shell-sort）"><a href="#3-4-希尔排序（shell-sort）" class="headerlink" title="3.4 希尔排序（shell sort）"></a>3.4 希尔排序（shell sort）</h3><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p><h4 id="3-4-1-算法描述"><a href="#3-4-1-算法描述" class="headerlink" title="3.4.1 算法描述"></a>3.4.1 算法描述</h4><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="3-4-2-动图演示"><a href="#3-4-2-动图演示" class="headerlink" title="3.4.2 动图演示"></a>3.4.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/shell_sort.gif" title="[缩小增量排序]"><h4 id="3-4-3-代码实现"><a href="#3-4-3-代码实现" class="headerlink" title="3.4.3 代码实现"></a>3.4.3 代码实现</h4><pre><code class="java">public static int[] ShellSort(int[] array) {    int len = array.length;    int temp, gap = len / 2;    while (gap &gt; 0) {        for (int i = gap; i &lt; len; i++) {            temp = array[i];            int preIndex = i - gap;            while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {                array[preIndex + gap] = array[preIndex];                preIndex -= gap;            }            array[preIndex + gap] = temp;        }        gap /= 2;    }    return array;}</code></pre><h3 id="3-5-选择排序（selection-sort）"><a href="#3-5-选择排序（selection-sort）" class="headerlink" title="3.5 选择排序（selection sort）"></a>3.5 选择排序（selection sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="3-5-1-算法描述"><a href="#3-5-1-算法描述" class="headerlink" title="3.5.1 算法描述"></a>3.5.1 算法描述</h4><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="3-5-2-动图演示"><a href="#3-5-2-动图演示" class="headerlink" title="3.5.2 动图演示"></a>3.5.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/selection_sort.gif" title="[选择排序]"><h4 id="3-5-3-代码实现"><a href="#3-5-3-代码实现" class="headerlink" title="3.5.3 代码实现"></a>3.5.3 代码实现</h4><pre><code class="java">public static int[] selectionSort(int[] array) {    if (array.length == 0)        return array;    for (int i = 0; i &lt; array.length; i++) {        int minIndex = i;        for (int j = i; j &lt; array.length; j++) {            if (array[j] &lt; array[minIndex]) //找到最小的数                minIndex = j; //将最小数的索引保存        }        int temp = array[minIndex];        array[minIndex] = array[i];        array[i] = temp;    }    return array;}</code></pre><h3 id="3-6-堆排序（Heap-sort）"><a href="#3-6-堆排序（Heap-sort）" class="headerlink" title="3.6 堆排序（Heap sort）"></a>3.6 堆排序（Heap sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="3-6-1-算法描述"><a href="#3-6-1-算法描述" class="headerlink" title="3.6.1 算法描述"></a>3.6.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="3-6-2-动图演示"><a href="#3-6-2-动图演示" class="headerlink" title="3.6.2 动图演示"></a>3.6.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/heap_sort.gif" title="[堆排序]"><h4 id="3-6-3-代码实现"><a href="#3-6-3-代码实现" class="headerlink" title="3.6.3 代码实现"></a>3.6.3 代码实现</h4><pre><code class="java">//声明全局变量，用于记录数组array的长度；static int len;// 堆排序算法public static int[] heapSort(int[] array) {    len = array.length;    if (len &lt; 1) return array;    //1.构建一个最大堆    buildMaxHeap(array);    System.out.println(&quot;第一次构建最大堆：&quot;+ Arrays.toString(array));    //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆    while (len &gt; 0) {        swap(array, 0, len - 1);        len--;        adjustHeap(array, 0);        System.out.println(&quot;len:&quot;+len+&quot;构建后为：&quot;+Arrays.toString(array));    }    return array;}//建立最大堆public static void buildMaxHeap(int[] array) {    //从最后一个非叶子节点开始向上构造最大堆    for (int i = (len/2 - 1); i &gt;= 0; i--) { //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1)        adjustHeap(array, i);    }}//调整使之成为最大堆 public static void adjustHeap(int[] array, int i) {    int maxIndex = i;    //如果有左子树，且左子树大于父节点，则将最大指针指向左子树    if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])        maxIndex = i * 2;    //如果有右子树，且右子树大于父节点，则将最大指针指向右子树    if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])        maxIndex = i * 2 + 1;    //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。    if (maxIndex != i) {        swap(array, maxIndex, i);        adjustHeap(array, maxIndex);    }}</code></pre><h3 id="3-7-归并排序（Merge-sort）"><a href="#3-7-归并排序（Merge-sort）" class="headerlink" title="3.7 归并排序（Merge sort）"></a>3.7 归并排序（Merge sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h4 id="3-7-1-算法描述"><a href="#3-7-1-算法描述" class="headerlink" title="3.7.1 算法描述"></a>3.7.1 算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="3-7-2-动图演示"><a href="#3-7-2-动图演示" class="headerlink" title="3.7.2 动图演示"></a>3.7.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/merge_sort.gif" title="[归并排序]"><h4 id="3-7-3-代码实现"><a href="#3-7-3-代码实现" class="headerlink" title="3.7.3 代码实现"></a>3.7.3 代码实现</h4><pre><code class="java">// 归并排序public static int[] MergeSort(int[] array) {    if (array.length &lt; 2) return array;    int mid = array.length / 2;    int[] left = Arrays.copyOfRange(array, 0, mid);    int[] right = Arrays.copyOfRange(array, mid, array.length);    return merge(MergeSort(left), MergeSort(right));}//归并排序——将两段排序好的数组结合成一个排序数组public static int[] merge(int[] left, int[] right) {    int[] result = new int[left.length + right.length];    for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {        if (i &gt;= left.length)            result[index] = right[j++];        else if (j &gt;= right.length)            result[index] = left[i++];        else if (left[i] &gt; right[j])            result[index] = right[j++];        else            result[index] = left[i++];    }    return result;}</code></pre><h3 id="3-8-计数排序（counting-sort）"><a href="#3-8-计数排序（counting-sort）" class="headerlink" title="3.8 计数排序（counting sort）"></a>3.8 计数排序（counting sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="3-8-1-算法描述"><a href="#3-8-1-算法描述" class="headerlink" title="3.8.1 算法描述"></a>3.8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="3-8-2-动图演示"><a href="#3-8-2-动图演示" class="headerlink" title="3.8.2 动图演示"></a>3.8.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/counting_sort.gif" title="[计数排序]"><h4 id="3-8-3-代码实现"><a href="#3-8-3-代码实现" class="headerlink" title="3.8.3 代码实现"></a>3.8.3 代码实现</h4><pre><code class="java">// 计数排序public static int[] CountingSort(int[] array) {    if (array.length == 0) return array;    int bias, min = array[0], max = array[0];    for (int i = 1; i &lt; array.length; i++) {        if (array[i] &gt; max)            max = array[i];        if (array[i] &lt; min)            min = array[i];    }    bias = 0 - min;    int[] bucket = new int[max - min + 1];    Arrays.fill(bucket, 0);    for (int i = 0; i &lt; array.length; i++) {        bucket[array[i] + bias]++;    }    int index = 0, i = 0;    while (index &lt; array.length) {        if (bucket[i] != 0) {            array[index] = i - bias;            bucket[i]--;            index++;        } else            i++;    }    return array;}</code></pre><h3 id="3-9-桶排序（Bucket-sort）"><a href="#3-9-桶排序（Bucket-sort）" class="headerlink" title="3.9 桶排序（Bucket sort）"></a>3.9 桶排序（Bucket sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="3-9-1-算法描述"><a href="#3-9-1-算法描述" class="headerlink" title="3.9.1 算法描述"></a>3.9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="3-9-2-动图演示"><a href="#3-9-2-动图演示" class="headerlink" title="3.9.2 动图演示"></a>3.9.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/bucket_sort.gif" title="[桶排序]"><h4 id="3-9-3-代码实现"><a href="#3-9-3-代码实现" class="headerlink" title="3.9.3 代码实现"></a>3.9.3 代码实现</h4><pre><code class="java">// 桶排序public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) {    if (array == null || array.size() &lt; 2)        return array;    int max = array.get(0), min = array.get(0);    // 找到最大值最小值    for (int i = 0; i &lt; array.size(); i++) {        if (array.get(i) &gt; max)            max = array.get(i);        if (array.get(i) &lt; min)            min = array.get(i);    }    int bucketCount = (max - min) / bucketSize + 1;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);    ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; bucketCount; i++) {        bucketArr.add(new ArrayList&lt;Integer&gt;());    }    for (int i = 0; i &lt; array.size(); i++) {        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));    }    for (int i = 0; i &lt; bucketCount; i++) {        if (bucketSize == 1) { // 如果带排序数组中有重复数字时            for (int j = 0; j &lt; bucketArr.get(i).size(); j++)                resultArr.add(bucketArr.get(i).get(j));        } else {            if (bucketCount == 1)                bucketSize--;            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);            for (int j = 0; j &lt; temp.size(); j++)                resultArr.add(temp.get(j));        }    }    return resultArr;}</code></pre><h3 id="3-10-基数排序-（Radix-sort）"><a href="#3-10-基数排序-（Radix-sort）" class="headerlink" title="3.10 基数排序 （Radix sort）"></a>3.10 基数排序 （Radix sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="3-10-1-算法描述"><a href="#3-10-1-算法描述" class="headerlink" title="3.10.1 算法描述"></a>3.10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="3-10-2-动图演示"><a href="#3-10-2-动图演示" class="headerlink" title="3.10.2 动图演示"></a>3.10.2 动图演示</h4><img src="/wiki/algorithm/十大经典排序算法/radix_sort.gif" title="[基数排序]"><h4 id="3-10-3-代码实现"><a href="#3-10-3-代码实现" class="headerlink" title="3.10.3 代码实现"></a>3.10.3 代码实现</h4><pre><code class="java">//基数排序public static int[] RadixSort(int[] array) {    if (array == null || array.length &lt; 2)        return array;    // 1.先算出最大数的位数；    int max = array[0];    for (int i = 1; i &lt; array.length; i++) {        max = Math.max(max, array[i]);    }    int maxDigit = 0;    while (max != 0) {        max /= 10;        maxDigit++;    }    int mod = 10, div = 1;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();    for (int i = 0; i &lt; 10; i++)        bucketList.add(new ArrayList&lt;Integer&gt;());    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) {        for (int j = 0; j &lt; array.length; j++) {            int num = (array[j] % mod) / div;            bucketList.get(num).add(array[j]);        }        int index = 0;        for (int j = 0; j &lt; bucketList.size(); j++) {            for (int k = 0; k &lt; bucketList.get(j).size(); k++)                array[index++] = bucketList.get(j).get(k);            bucketList.get(j).clear();        }    }    return array;}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/zhi-ming/p/10453124.html" rel="external nofollow noopener noreferrer" target="_blank">十大经典排序算法（动图演示）</a></li><li><a href="https://blog.csdn.net/wq_1995/article/details/81937926#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89" rel="external nofollow noopener noreferrer" target="_blank">十大经典排序算法总结（Java语言实现）</a></li><li><a href="https://www.sohu.com/a/278768401_478315" rel="external nofollow noopener noreferrer" target="_blank">【图解数据结构】 一组动画彻底理解桶排序 </a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>default</title>
      <link href="/wiki/python/default/"/>
      <url>/wiki/python/default/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用idea插件汇总</title>
      <link href="/wiki/tools/%E5%B8%B8%E7%94%A8idea%20%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
      <url>/wiki/tools/%E5%B8%B8%E7%94%A8idea%20%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合框架</title>
      <link href="/wiki/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/wiki/java/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="java8集合架构"><a href="#java8集合架构" class="headerlink" title="java8集合架构"></a>java8集合架构</h2><h3 id="常用成员"><a href="#常用成员" class="headerlink" title="常用成员"></a>常用成员</h3><img src="/wiki/java/java集合框架/集合框架架构.png" title="[集合常用成员]"><h3 id="Collection-接口系单列集合"><a href="#Collection-接口系单列集合" class="headerlink" title="Collection 接口系单列集合"></a>Collection 接口系单列集合</h3><img src="/wiki/java/java集合框架/Iterable.png" title="[collection]"><h3 id="Map-接口系双列集合"><a href="#Map-接口系双列集合" class="headerlink" title="Map 接口系双列集合"></a>Map 接口系双列集合</h3><img src="/wiki/java/java集合框架/Map.png" title="[Map]"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud架构</title>
      <link href="/wiki/spring/springcloud/SpringCloud%E6%9E%B6%E6%9E%84/"/>
      <url>/wiki/spring/springcloud/SpringCloud%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><img src="/wiki/spring/springcloud/SpringCloud架构/Springcloud微服务架构图1.png" title="[]"><img src="/wiki/spring/springcloud/SpringCloud架构/Springcloud微服务架构图2.png" title="[]"><hr><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li><h3 id="netflix-Eureka："><a href="#netflix-Eureka：" class="headerlink" title="netflix-Eureka："></a>netflix-Eureka：</h3><p>各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</p></li><li><h3 id="netflix-Ribbon："><a href="#netflix-Ribbon：" class="headerlink" title="netflix-Ribbon："></a>netflix-Ribbon：</h3><p>服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p></li><li><h3 id="netflix-Feign："><a href="#netflix-Feign：" class="headerlink" title="netflix-Feign："></a>netflix-Feign：</h3><p>基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p></li><li><h3 id="netflix-Hystrix："><a href="#netflix-Hystrix：" class="headerlink" title="netflix-Hystrix："></a>netflix-Hystrix：</h3><p>发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p></li><li><h3 id="netflix-Zuul："><a href="#netflix-Zuul：" class="headerlink" title="netflix-Zuul："></a>netflix-Zuul：</h3><p>如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</p></li><li><h3 id="netflix-Archaius"><a href="#netflix-Archaius" class="headerlink" title="netflix-Archaius:"></a>netflix-Archaius:</h3><p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</p><hr><p>​</p></li><li><h3 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h3><p>配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。</p></li><li><h3 id="Cloud-Bus："><a href="#Cloud-Bus：" class="headerlink" title="Cloud Bus："></a>Cloud Bus：</h3><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p></li><li><h3 id="Spring-Cloud-Sleuth："><a href="#Spring-Cloud-Sleuth：" class="headerlink" title="Spring Cloud Sleuth："></a>Spring Cloud Sleuth：</h3><p>日志收集工具包，封装了Dapper,Zipkin和HTrace操作。</p></li><li><h3 id="Spring-Cloud-Data-Flow："><a href="#Spring-Cloud-Data-Flow：" class="headerlink" title="Spring Cloud Data Flow："></a>Spring Cloud Data Flow：</h3><p>大数据操作工具，通过命令行方式操作数据流。</p></li><li><h3 id="Spring-Cloud-Security："><a href="#Spring-Cloud-Security：" class="headerlink" title="Spring Cloud Security："></a>Spring Cloud Security：</h3><p>安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。</p></li><li><h3 id="Spring-Cloud-Consul："><a href="#Spring-Cloud-Consul：" class="headerlink" title="Spring Cloud Consul："></a>Spring Cloud Consul：</h3><p>封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p></li><li><h3 id="Spring-Cloud-Zookeeper："><a href="#Spring-Cloud-Zookeeper：" class="headerlink" title="Spring Cloud Zookeeper："></a>Spring Cloud Zookeeper：</h3><p>操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。</p></li><li><h3 id="Spring-Cloud-Stream："><a href="#Spring-Cloud-Stream：" class="headerlink" title="Spring Cloud Stream："></a>Spring Cloud Stream：</h3><p>数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</p></li><li><h3 id="Spring-Cloud-CLI："><a href="#Spring-Cloud-CLI：" class="headerlink" title="Spring Cloud CLI："></a>Spring Cloud CLI：</h3><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p></li><li><h3 id="Spring-Cloud-for-Cloud-Foundry："><a href="#Spring-Cloud-for-Cloud-Foundry：" class="headerlink" title="Spring Cloud for Cloud Foundry："></a>Spring Cloud for Cloud Foundry：</h3><p>通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><p><a href="https://blog.csdn.net/wujian_csdn_csdn/article/details/81701320" rel="external nofollow noopener noreferrer" target="_blank">SpringCloud微服务架构</a></p><p>​</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot 启动流程分析</title>
      <link href="/wiki/spring/springboot/springboot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/wiki/spring/springboot/springboot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-启动入口-（SrpingApplication）"><a href="#1-启动入口-（SrpingApplication）" class="headerlink" title="1.启动入口 （SrpingApplication）"></a>1.启动入口 （SrpingApplication）</h2><p> 大家熟悉的springboot的启动类，@SpringBootApplicationv + psvm（main方法）+ new SpringApplication().run(XXXX.class, args)</p><pre><code class="java">@SpringBootApplicationpublic class SummaryApplication {    public static void main(String[] args) {        SpringApplication application = new SpringApplication(); // 2        application.run(SummaryApplication.class, args); //3//      SpringApplication.run(SummaryApplication.class, args);  也可简化调用静态方法    }}</code></pre><h3 id="1-1-SpringBootApplication-注解"><a href="#1-1-SpringBootApplication-注解" class="headerlink" title="1.1 @SpringBootApplication 注解"></a>1.1 @SpringBootApplication 注解</h3><p>通过源码发现该注解只是@Configuration，@EnableAutoConfiguration，@ComponentScan 三个注解的组合，这是在springboot 1.5以后为这三个注解做的一个简写。接下来简单说下这三个注解的功能：</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration //1.1.1 注册为配置类@EnableAutoConfiguration //1.1.2 配置可自动装配@ComponentScan(excludeFilters = { //1.1.3 声明可扫描Bean   @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),  @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {  ...}</code></pre><h4 id="1-1-1-SpringBootConfiguration"><a href="#1-1-1-SpringBootConfiguration" class="headerlink" title="1.1.1 @SpringBootConfiguration"></a>1.1.1 @SpringBootConfiguration</h4><p>该注解就是spirng ioc容器中java config 配置方式的@Configuration ，注册当前类为spring ioc容器的配置类。</p><p>搭配@bean注解创建一个简单spring ioc配置类</p><pre><code class="java"> @Configuration      public class Conf {          @Bean          public Car car() {             Car car = new Car();              car.setWheel(wheel());              return car;          }         @Bean          public Wheel wheel() {              return new Wheel();          }      }</code></pre><h4 id="1-1-2-EnableAutoConfiguration"><a href="#1-1-2-EnableAutoConfiguration" class="headerlink" title="1.1.2 @EnableAutoConfiguration"></a>1.1.2 @EnableAutoConfiguration</h4><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class) //最为重要public @interface EnableAutoConfiguration {   String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;   /**    * Exclude specific auto-configuration classes such that they will never be applied.    * @return the classes to exclude    */   Class&lt;?&gt;[] exclude() default {};   /**    * Exclude specific auto-configuration class names such that they will never be    * applied.    * @return the class names to exclude    * @since 1.3.0    */   String[] excludeName() default {};}</code></pre><p>@EnableAutoConfiguration借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p><p><strong>最关键的要属@Import(EnableAutoConfigurationImportSelector.class)</strong> ，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p><h4 id="1-1-3-ComponentScan"><a href="#1-1-3-ComponentScan" class="headerlink" title="1.1.3 @ComponentScan"></a>1.1.3 @ComponentScan</h4><p>@ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p><h2 id="2-构造器（Constructor）"><a href="#2-构造器（Constructor）" class="headerlink" title="2.构造器（Constructor）"></a>2.构造器（Constructor）</h2><pre><code class="java">/** * Create a new {@link SpringApplication} instance. The application context will load * beans from the specified primary sources (see {@link SpringApplication class-level} * documentation for details. The instance can be customized before calling * {@link #run(String...)}. * @param resourceLoader the resource loader to use * @param primarySources the primary bean sources * @see #run(Class, String[]) * @see #setSources(Set) */@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {   this.resourceLoader = resourceLoader;   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);   this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));   //2.1 判断当前程序类型   this.webApplicationType = WebApplicationType.deduceFromClasspath();   //2.2 使用SpringFactoriesLoader 实例化所有可用的初始器   setInitializers((Collection)                            getSpringFactoriesInstances(ApplicationContextInitializer.class));   //2.3 使用SpringFactoriesLoader 实例化所有可用的监听器  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));   //2.4 配置应用主方法所在类   this.mainApplicationClass = deduceMainApplicationClass();}</code></pre><h4 id="2-1-判断当前程序类型"><a href="#2-1-判断当前程序类型" class="headerlink" title="2.1 判断当前程序类型"></a>2.1 判断当前程序类型</h4><p>根据classpath里面是否存在某个特征类</p><p>（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</p><pre><code>/** * The application should not run as a web application and should not start an * embedded web server. */NONE,/** * The application should run as a servlet-based web application and should start an * embedded servlet web server. */SERVLET,/** * The application should run as a reactive web application and should start an * embedded reactive web server. */REACTIVE;</code></pre><h2 id="3-启动方法（RUN）"><a href="#3-启动方法（RUN）" class="headerlink" title="3.启动方法（RUN）"></a>3.启动方法（RUN）</h2><p>初始化完成之后就进到了run方法，run方法完成了所有Spring的整个启动过程：</p><ul><li><p>准备Environment</p></li><li><p>发布事件</p></li><li><p>创建上下文、bean</p></li><li><p>刷新上下文</p></li><li><p>结束，</p><p>其中穿插了很多监听器的动作，并且很多逻辑都是靠各种监听器的实现类执行的。</p></li></ul><pre><code class="java">/** * Run the Spring application, creating and refreshing a new * {@link ApplicationContext}. * @param args the application arguments (usually passed from a Java main method) * @return a running {@link ApplicationContext} */public ConfigurableApplicationContext run(String... args) {   //开启时钟计时   StopWatch stopWatch = new StopWatch();   stopWatch.start();   //spirng 上下文   ConfigurableApplicationContext context = null;   //启动异常报告容器   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();   //开启设置，让系统模拟不存在io设备   configureHeadlessProperty();   // 3.1 初始化SpringApplicationRunListener 监听器，并进行封装   SpringApplicationRunListeners listeners = getRunListeners(args);   listeners.starting();   try {      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);     //3.2 Environment 的准备       ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);      configureIgnoreBeanInfo(environment);      Banner printedBanner = printBanner(environment); // 打印标语 彩蛋     //3.3 创建上下文实例      context = createApplicationContext();     //异常播报器，默认有org.springframework.boot.diagnostics.FailureAnalyzers      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,            new Class[] { ConfigurableApplicationContext.class }, context);     //3.4 容器初始化      prepareContext(context, environment, listeners, applicationArguments, printedBanner);     //3.5 刷新上下文容器       refreshContext(context);     //给实现类留的钩子，这里是一个空方法。      afterRefresh(context, applicationArguments);      stopWatch.stop();      if (this.logStartupInfo) {         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);      }      listeners.started(context);      callRunners(context, applicationArguments);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, listeners);      throw new IllegalStateException(ex);   }   try {      listeners.running(context);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, null);      throw new IllegalStateException(ex);   }   return context;}</code></pre><h3 id="3-1-SpringApplicationRunListener-的使用"><a href="#3-1-SpringApplicationRunListener-的使用" class="headerlink" title="3.1 SpringApplicationRunListener 的使用"></a>3.1 SpringApplicationRunListener 的使用</h3><p>首先通过getSpringFactoriesInstances 获取到所有实现SpringApplicationRunListener  接口的实例，默认情况下该接口的实现类只有 EventPublishingRunListener  他的主要作用是作为springboot 的一个广播器</p><pre><code class="java">public interface SpringApplicationRunListener {  /**EventPublishingRunListener 前期采用 SimpleApplicationEventMulticaster.multicastEvent(ApplicationEvent) 进行广播  **/   default void starting() {}    default void environmentPrepared(ConfigurableEnvironment environment) {}   default void contextPrepared(ConfigurableApplicationContext context) {}   default void contextLoaded(ConfigurableApplicationContext context) {}  /**  EventPublishingRunListener 后期采用 context.publishEvent(ApplicationEvent)  **/   default void started(ConfigurableApplicationContext context) {}   default void running(ConfigurableApplicationContext context) {}   default void failed(ConfigurableApplicationContext context, Throwable exception) {}}</code></pre><h3 id="3-2-prepareEnvironment"><a href="#3-2-prepareEnvironment" class="headerlink" title="3.2 prepareEnvironment"></a>3.2 prepareEnvironment</h3><p>一般在写业务代码时使用的都是只读类型的接口<code>Environment</code>，该接口是对运行程序环境的抽象，是保存系统配置的中心，而在启动过程中使用的则是可编辑的<code>ConfigurableEnvironment</code>。接口的UML类图如下，提供了合并父环境、添加active profile以及一些设置解析配置文件方式的接口。</p><p>其中一个比较重要的方法<code>MutablePropertySources getPropertySources();</code>，该方法返回一个可编辑的<code>PropertySources</code>，如果有在启动阶段自定义环境的PropertySources的需求，就可以通过该方法设置。</p><pre><code class="java">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,      ApplicationArguments applicationArguments) {   // Create and configure the environment  //根据不同环境不同的Enviroment （StandardServletEnvironment，StandardReactiveWebEnvironment，StandardEnvironment）   ConfigurableEnvironment environment = getOrCreateEnvironment();  //填充启动类参数到enviroment 对象   configureEnvironment(environment, applicationArguments.getSourceArgs());  //更新参数  ConfigurationPropertySources.attach(environment);  //发布事件   listeners.environmentPrepared(environment);  //绑定主类   bindToSpringApplication(environment);   if (!this.isCustomEnvironment) {//转换environment的类型，但这里应该类型和deduce的相同不用转换      environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,            deduceEnvironmentClass());   }  //将现有参数有封装成proertySources   ConfigurationPropertySources.attach(environment);   return environment;}</code></pre><h3 id="3-3-创建springApplicationContext-上下文"><a href="#3-3-创建springApplicationContext-上下文" class="headerlink" title="3.3  创建springApplicationContext 上下文"></a>3.3  创建springApplicationContext 上下文</h3><img src="/wiki/spring/springboot/springboot%20启动流程分析/springApplicationContext.webp" title="[启动流程分析]"><p>继承的三个父类接口里，<code>Closeable</code>提供了关闭时资源释放的接口，<code>Lifecycle</code>是提供对生命周期控制的接口(start\stop)以及查询当前运行状态的接口，<code>ApplicationContext</code>则是配置上下文的中心配置接口，继承了其他很多配置接口，其本身提供查询诸如id、应用程序名等上下文档案信息的只读接口，以及构建自动装配bean的工厂。</p><ul><li>EnvironmentCapable</li></ul><p>提供Environment接口。</p><ul><li>MessageSource</li></ul><p>国际化资源接口。</p><ul><li>ApplicationEventPublisher</li></ul><p>事件发布器。</p><ul><li>ResourcePatternResolver</li></ul><p>资源加载器。</p><ul><li>HierarchicalBeanFactory、ListableBeanFactory</li></ul><p>这两个都继承了bean容器的根接口<code>BeanFactory</code></p><p>简而言之就是根据Web容器类型的不同来创建不用的上下文实例。</p><h3 id="3-4-上下文初始化"><a href="#3-4-上下文初始化" class="headerlink" title="3.4 上下文初始化"></a>3.4 上下文初始化</h3><pre><code class="java">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,      SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {  //绑定环境   context.setEnvironment(environment);  //如果application有设置beanNameGenerator、resourceLoader就将其注入到上下文中，并将转换工具也注入到上下文中  postProcessApplicationContext(context);  //调用初始化的切面   applyInitializers(context);  //发布ApplicationContextInitializedEvent事件   listeners.contextPrepared(context);  //日志   if (this.logStartupInfo) {      logStartupInfo(context.getParent() == null);      logStartupProfileInfo(context);   }   // Add boot specific singleton beans   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();   beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);   if (printedBanner != null) {      beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);   }   if (beanFactory instanceof DefaultListableBeanFactory) {     //如果bean名相同的话是否允许覆盖，默认为false，相同会抛出异常      ((DefaultListableBeanFactory) beanFactory)            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);   }   if (this.lazyInitialization) {      context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());   }   // Load the sources  // 这里获取到的是BootstrapImportSelectorConfiguration这个class，而不是自己写的启动来，这个class是在之前注册的BootstrapApplicationListener的监听方法中注入的   Set&lt;Object&gt; sources = getAllSources();   Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);  //加载sources 到上下文中   load(context, sources.toArray(new Object[0]));  //发布ApplicationPreparedEvent事件   listeners.contextLoaded(context);}</code></pre><h3 id="3-5-刷新上下文"><a href="#3-5-刷新上下文" class="headerlink" title="3.5 刷新上下文"></a>3.5 刷新上下文</h3><pre><code>AbstractApplicationContext</code></pre><pre><code class="java">public void refresh() throws BeansException, IllegalStateException {    synchronized (this.startupShutdownMonitor) {        //记录启动时间、状态，web容器初始化其property，复制listener        prepareRefresh();        //这里返回的是context的BeanFactory        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        //beanFactory注入一些标准组件，例如ApplicationContextAwareProcessor，ClassLoader等        prepareBeanFactory(beanFactory);        try {            //给实现类留的一个钩子，例如注入BeanPostProcessors，这里是个空方法            postProcessBeanFactory(beanFactory);            // 调用切面方法            invokeBeanFactoryPostProcessors(beanFactory);            // 注册切面bean            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // bean工厂注册一个key为applicationEventMulticaster的广播器            initApplicationEventMulticaster();            // 给实现类留的一钩子，可以执行其他refresh的工作，这里是个空方法            onRefresh();            // 将listener注册到广播器中            registerListeners();            // 实例化未实例化的bean            finishBeanFactoryInitialization(beanFactory);            // 清理缓存，注入DefaultLifecycleProcessor，发布ContextRefreshedEvent            finishRefresh();        }        catch (BeansException ex) {            if (logger.isWarnEnabled()) {                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            }            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &#39;active&#39; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        }        finally {            // Reset common introspection caches in Spring&#39;s core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();        }    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><p><a href="https://www.jianshu.com/p/a46392c5cc50" rel="external nofollow noopener noreferrer" target="_blank">springboot启动的流程图</a></p></li><li><p><a href="https://blog.csdn.net/zlc3323/article/details/100137222?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" rel="external nofollow noopener noreferrer" target="_blank">能说下springboot启动原理吗</a></p></li><li><p><a href="https://www.jianshu.com/p/603d125f21b3" rel="external nofollow noopener noreferrer" target="_blank">Springboot 启动过程分析</a></p></li><li><p><a href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e" rel="external nofollow noopener noreferrer" target="_blank">springboot结构图</a></p><p>​</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>活用linux命令:netstat</title>
      <link href="/wiki/linux/shell/%E6%B4%BB%E7%94%A8linux%E5%91%BD%E4%BB%A4-netstat/"/>
      <url>/wiki/linux/shell/%E6%B4%BB%E7%94%A8linux%E5%91%BD%E4%BB%A4-netstat/</url>
      
        <content type="html"><![CDATA[<p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。  </p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code>$ netstat [-acCeFghilMnNoprstuvVwx] [-A&lt;网络类型&gt;][--ip]</code></pre><h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p> netstat 用于显示IP，TCP，UDP和ICMP协议相关的统计数据，一般用于检验本机端口的网络连接情况。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>-a或–all</td><td>显示所有连线中的Socket</td></tr><tr><td>-A&lt;网络类型&gt;或–&lt;网络类型&gt;</td><td>列出该网络类型连线中的相关地址</td></tr><tr><td>-c或–continuous</td><td>持续列出网络状态</td></tr><tr><td>-C或–cache</td><td>显示路由器配置的快取信息</td></tr><tr><td>-e或–extend</td><td>显示网络其他相关信息</td></tr><tr><td>-F或–fib</td><td>显示FIB</td></tr><tr><td>-g或–groups</td><td>显示多重广播功能群组组员名单</td></tr><tr><td>-h或–help</td><td>在线帮助</td></tr><tr><td>-i或–interfaces</td><td>显示网络界面信息表单</td></tr><tr><td>-l或–listening</td><td>显示监控中的服务器的Socket</td></tr><tr><td>-M或–masquerade</td><td>显示伪装的网络连线</td></tr><tr><td>-n或–numeric</td><td>直接使用IP地址，而不通过域名服务器</td></tr><tr><td>-N或–netlink或–symbolic</td><td>显示网络硬件外围设备的符号连接名称</td></tr><tr><td>-o或–timers</td><td>显示计时器</td></tr><tr><td>-p或–programs</td><td>显示正在使用Socket的程序识别码和程序名称</td></tr><tr><td>-r或–route</td><td>显示Routing Table</td></tr><tr><td>-s或–statistice</td><td>显示网络工作信息统计表</td></tr><tr><td>-t或–tcp</td><td>显示TCP传输协议的连线状况</td></tr><tr><td>-u或–udp</td><td>显示UDP传输协议的连线状况</td></tr><tr><td>-v或–verbose</td><td>显示指令执行过程</td></tr><tr><td>-V或–version</td><td>显示版本信息</td></tr><tr><td>-w或–raw</td><td>显示RAW传输协议的连线状况</td></tr><tr><td>-x或–unix</td><td>此参数的效果和指定”-A unix”参数相同</td></tr><tr><td>–ip或–inet</td><td>此参数的效果和指定”-A inet”参数相同</td></tr></tbody></table><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="无参数使用"><a href="#无参数使用" class="headerlink" title="无参数使用"></a>无参数使用</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://yelog.org/2017/01/10/linux-command%EF%BC%8841%EF%BC%89-netstat/" rel="external nofollow noopener noreferrer" target="_blank">每天一个linux命令（41）: netstat</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/wiki/java/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/wiki/java/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><img src="/wiki/java/JVM内存模型/jvmcontains.png" title="[jvm组成]"><p><strong>JVM由以下三个部分组成：</strong></p><ul><li><p>1.类装载子系统</p><p>加载class文件到JVM的内存区域即运行时数据区</p></li><li><p>2.运行时数据区</p><p>JVM对应的内存区域，分为几个部分，用于程序执行时将不同的数据存放到不同的区域，从而对每个区域分别管理，每个区域完成自己的职责</p></li><li><p>3.字节码执行引擎</p><p>运行字节码文件</p></li></ul><h2 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h2><img src="/wiki/java/JVM内存模型/java内存模型.png" title="[jvm 内存模型]"><h2 id="各组件说明"><a href="#各组件说明" class="headerlink" title="各组件说明"></a>各组件说明</h2><h3 id="1-线程私有"><a href="#1-线程私有" class="headerlink" title="1.线程私有"></a>1.线程私有</h3><h4 id="1-1虚拟机栈和本地方法栈"><a href="#1-1虚拟机栈和本地方法栈" class="headerlink" title="1.1虚拟机栈和本地方法栈"></a>1.1虚拟机栈和本地方法栈</h4><p>线程私有，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。Java虚拟机栈是由一个个栈帧组成，线程在执行一个方法时，便会向栈中放入一个栈帧，每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法出口信息。局部变量表主要存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><ul><li>StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛StackOverFlowError异常。</li><li>OutOfMemoryError：若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>　　Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p>本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><h4 id="1-2程序计数器"><a href="#1-2程序计数器" class="headerlink" title="1.2程序计数器"></a>1.2程序计数器</h4><p>java虚拟机的多线程是通过线程轮流切换并分配CPU的时间片的方式实现的，因此在任何时刻一个处理器（如果是多核处理器，则只是一个核）都只会处理一个线程，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，因此这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><strong>注意 ：</strong>程序计数器是唯不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="2-线程共享"><a href="#2-线程共享" class="headerlink" title="2.线程共享"></a>2.线程共享</h3><h4 id="2-1-堆区"><a href="#2-1-堆区" class="headerlink" title="2.1 堆区"></a>2.1 堆区</h4><p>Java堆是java应用程序关系最密切的内存空间，几乎所有对象都存放到其中，并且java堆完全是自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显示的释放。</p><p>根据垃圾回收机制不同，java堆有可能拥有不同的结构。最为常见的就是将整个java堆分为新生代和老年代。其中新生代存放新声的对象或者年龄不大的对象，老年代则存放老年对象。</p><p>新生代分为eden区、s0区、s1区，s0区和s1区被称为from和to区域，他们是两块大小相等并且可以互换角色的空间。</p><p>绝大多数情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存货，则会进入s0或者s1区，之后每经过一次新生代回收，如果对象存活则它的年纪就加1，</p><p>当对象达到一定年龄后，进入老年代。</p><h4 id="2-2-方法区"><a href="#2-2-方法区" class="headerlink" title="2.2 方法区"></a>2.2 方法区</h4><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/aiqiqi/p/10770864.html#_label1" rel="external nofollow noopener noreferrer" target="_blank">JVM内存模型和面试题解析</a></li><li><a href="https://www.processon.com/view/5e2ef355e4b04579e40d5875" rel="external nofollow noopener noreferrer" target="_blank">JVM内存模型图</a></li><li><a href="https://blog.csdn.net/qq_34805255/article/details/98850311" rel="external nofollow noopener noreferrer" target="_blank">深入理解JVM（1）——JVM内存模型——JVM运行时数据区</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springMvc处理流程</title>
      <link href="/wiki/spring/springmvc/springMvc%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
      <url>/wiki/spring/springmvc/springMvc%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-mvc相关组件及介绍"><a href="#spring-mvc相关组件及介绍" class="headerlink" title="spring mvc相关组件及介绍"></a>spring mvc相关组件及介绍</h1><ul><li><h4 id="DispatchServlet"><a href="#DispatchServlet" class="headerlink" title="DispatchServlet"></a>DispatchServlet</h4>java开发在经历了超级servlet阶段后，开始为servlet减负的尝试，MVC结构把servlet的工作分为frontController与Page Controller，前着进行必要请求的转发，后者负责具体的业务逻辑处理，DispathServlet就是frontController的角色，负责接收web请求建立连接，然后调用合适的处理类获得结果，返回。</li><li><h4 id="handlerMapping"><a href="#handlerMapping" class="headerlink" title="handlerMapping"></a>handlerMapping</h4>在DispatchServlet接收到客户端的请求之后，通过handlerMapping匹配到具体的处理类（handler），handler代表所有的次级控制类，除了我们常用的controller意外还有第三方WEB开发框架中的Page Controller组件。<br>handerMapping类的实现类有多个：</li></ul><ol><li>SimpleUrlHandlerMapping</li><li>ControllerClassnameHandlerMapping</li><li>DefaultAnnotationHandlerMapping(基于注解的配置方式)<br>这些hangdlerMapping一个dispatchSerlet中可以配置多个，他们通过实现的Ordered接口按照序列优先级执行</li></ol><ul><li><h4 id="Handler（Controller）"><a href="#Handler（Controller）" class="headerlink" title="Handler（Controller）"></a>Handler（Controller）</h4>在SpirngMvc中，任何可以用于Web请求处理的对象统称为handler，Controller是Handler中的一个特殊类型</li><li><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4>主要工作只是调用这个HandlerAdaptor“认识”的Handler的web请求处理方法，然后将处理结果转换为DispatcherServlet统一使用的ModelAndView就行。</li><li><h4 id="HanderExceptionResolver"><a href="#HanderExceptionResolver" class="headerlink" title="HanderExceptionResolver"></a>HanderExceptionResolver</h4>提供统一的异常处理方式，让handler的throws Exception看起来更加“理直气壮”</li></ul><h3 id="spring-mvc各组件交互流程"><a href="#spring-mvc各组件交互流程" class="headerlink" title="spring mvc各组件交互流程"></a>spring mvc各组件交互流程</h3><ul><li><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="/wiki/spring/springmvc/springMvc处理流程/springMvc处理流程图.png" title="[spring MVC 时序图]"></li><li><h4 id="步骤详细描述"><a href="#步骤详细描述" class="headerlink" title="步骤详细描述"></a>步骤详细描述</h4></li></ul><ol><li>DispatcherServlet 接收到满足web.xml配置的Http请求，daspatcherServlet通过handlerAdapter从HandlerMapping获取对应该请求得处理器</li><li>Handler 通过handlerRequest(request,reponse)处理具体的请求，然后返回处理结果ModelAndView</li><li>DispatcherServlet接收到ModelAndView后通过调用ViewResolve 组装View，返回View<br>4.DispatcherServlet返回处理结果</li></ol><h3 id="相关技术字典"><a href="#相关技术字典" class="headerlink" title="相关技术字典"></a>相关技术字典</h3><ol><li><h4 id="Restful-web-请求风格"><a href="#Restful-web-请求风格" class="headerlink" title="Restful web 请求风格"></a>Restful web 请求风格</h4> 采用Restful 架构的web请求分割的原则</li></ol><ul><li>每一个URI代表一种资源（URI中应该全是名词，动作操作全部传给Http协议）</li><li>客户端和服务端之间，传递这种资源的某种变现层</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”</li></ul><ol start="2"><li><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4> HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html" rel="external nofollow noopener noreferrer" target="_blank">理解RESTful架构</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP 协议入门</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springmvc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pageHelper的使用</title>
      <link href="/wiki/spring/springmvc/pageHelp%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/wiki/spring/springmvc/pageHelp%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pageHelper的使用"><a href="#pageHelper的使用" class="headerlink" title="pageHelper的使用"></a>pageHelper的使用</h1><h2 id="pageHelper"><a href="#pageHelper" class="headerlink" title="pageHelper"></a>pageHelper</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h3 id="第一种，RowBounds方式的调用"><a href="#第一种，RowBounds方式的调用" class="headerlink" title="第一种，RowBounds方式的调用"></a>第一种，RowBounds方式的调用</h3><pre><code>List&lt;Country&gt; list = sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(0, 10));</code></pre><h3 id="第二种，Mapper接口方式的调用，推荐这种使用方式。"><a href="#第二种，Mapper接口方式的调用，推荐这种使用方式。" class="headerlink" title="第二种，Mapper接口方式的调用，推荐这种使用方式。"></a>第二种，Mapper接口方式的调用，推荐这种使用方式。</h3><pre><code>PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);</code></pre><h3 id="第三种，Mapper接口方式的调用，推荐这种使用方式。"><a href="#第三种，Mapper接口方式的调用，推荐这种使用方式。" class="headerlink" title="第三种，Mapper接口方式的调用，推荐这种使用方式。"></a>第三种，Mapper接口方式的调用，推荐这种使用方式。</h3><pre><code>PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);</code></pre><h3 id="第四种，参数方法调用"><a href="#第四种，参数方法调用" class="headerlink" title="第四种，参数方法调用"></a>第四种，参数方法调用</h3><pre><code>//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper {    List&lt;Country&gt; selectByPageNumSize(            @Param(&quot;user&quot;) User user,            @Param(&quot;pageNum&quot;) int pageNum,            @Param(&quot;pageSize&quot;) int pageSize);}//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10);</code></pre><h3 id="第五种，参数对象"><a href="#第五种，参数对象" class="headerlink" title="第五种，参数对象"></a>第五种，参数对象</h3><p>如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页<br>有如下 User 对象</p><pre><code>public class User {    //其他fields    //下面两个参数名和 params 配置的名字一致    private Integer pageNum;    private Integer pageSize;}//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper {    List&lt;Country&gt; selectByPageNumSize(User user);}//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);</code></pre><h3 id="第六种，ISelect-接口方式"><a href="#第六种，ISelect-接口方式" class="headerlink" title="第六种，ISelect 接口方式"></a>第六种，ISelect 接口方式</h3><pre><code>//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() {    @Override    public void doSelect() {        countryMapper.selectGroupBy();    }});//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() {    @Override    public void doSelect() {        countryMapper.selectGroupBy();    }});//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() {    @Override    public void doSelect() {        countryMapper.selectLike(country);    }});//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country));</code></pre><blockquote><ul><li>​</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java2 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
